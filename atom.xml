<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DNA&#39; Blog</title>
  
  <subtitle>个人学习记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ssdna.github.io/"/>
  <updated>2018-05-03T02:31:29.224Z</updated>
  <id>http://ssdna.github.io/</id>
  
  <author>
    <name>DNA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>closure</title>
    <link href="http://ssdna.github.io/2018/05/02/closure/"/>
    <id>http://ssdna.github.io/2018/05/02/closure/</id>
    <published>2018-05-02T05:31:13.000Z</published>
    <updated>2018-05-03T02:31:29.224Z</updated>
    
    <content type="html"><![CDATA[<p>widipedia上，对闭包的解释如下：</p><p><code>In programming languages, a closure (also lexical closure or function closure) is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function[a] together with an environment.[1] The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.[b] A closure—unlike a plain function—allows the function to access those captured variables through the closure&#39;s copies of their values or references, even when the function is invoked outside their scope.</code></p><p>在编程语言中，闭包（也是词法闭包或函数闭包）是一种用一级函数语言实现词汇范围名称绑定的技术。 在操作上，封闭是一个存储功能[a]和环境的记录。[1] 环境是一个映射，它将函数的每个自由变量（在本地使用但在封闭范围中定义的变量）与创建闭包时绑定名称的值或引用相关联。[b]闭包 - 不像 一个简单的函数 - 允许函数通过闭包的值或引用的副本访问那些捕获的变量，即使函数在其作用域之外被调用。</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="external">Closure wikipedia</a>)</p></li><li><p><a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 6. Closures.</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;widipedia上，对闭包的解释如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;In programming languages, a closure (also lexical closure or function closure) is a technique for imple
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web前端涉及到的相关网络协议概述</title>
    <link href="http://ssdna.github.io/2018/04/21/Front-End-Related-Network-Protocals-Summary/"/>
    <id>http://ssdna.github.io/2018/04/21/Front-End-Related-Network-Protocals-Summary/</id>
    <published>2018-04-21T11:30:39.000Z</published>
    <updated>2018-04-21T11:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端涉及到的相关网络协议概述。（待完善）</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是建立在TCP协议之上的网络传输协议。</p><p>HTTP有如下几个特点：</p><ul><li>基于文本的</li><li>无状态，有会话的（Cookies）</li><li>可扩展的（Header）</li><li>可缓存的</li></ul><h4 id="HTTP-1-x"><a href="#HTTP-1-x" class="headerlink" title="HTTP/1.x"></a>HTTP/1.x</h4><h5 id="一个典型的会话过程："><a href="#一个典型的会话过程：" class="headerlink" title="一个典型的会话过程："></a>一个典型的会话过程：</h5><p>在像 HTTP 这样的Client-Server（客户端-服务器）协议中，会话分为三个阶段：</p><ol><li>客户端建立一条 TCP 连接（如果传输层不是 TCP，也可以是其他适合的连接）。</li><li>客户端发送请求并等待应答。</li><li>服务器处理请求并送回应答，回应包括一个状态码和对应的数据。</li></ol><p>从 HTTP/1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。</p><h5 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h5><ol><li>request：</li></ol><p>请求由以下元素组成：</p><ul><li>一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。</li><li>要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （<a href="http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。" target="_blank" rel="external">http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。</a></li><li>HTTP协议版本号。</li><li>为服务端表达其他信息的可选头部headers。</li><li>对于一些像POST这样的方法，报文的body就包含了发送的资源，这与回应报文的body类似。</li></ul><ol><li>response：</li></ol><p>响应报文包含了下面的元素：</p><ul><li>HTTP协议版本号。</li><li>一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。</li><li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li><li>HTTP headers，与请求头部类似。</li><li>可选项，比起请求报文，响应报文中更常见地包含获取的资源body。</li></ul><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>代理，转发HTTP消息。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>代理主要有如下几种作用：</p><ul><li>缓存（可以是公开的也可以是私有的，像浏览器的缓存）</li><li>过滤（像反病毒扫描，家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（对不同资源进行权限管理）</li><li>日志记录（允许存储历史信息）</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li><p>正向代理</p><p>  一般由客户端主动设置。<code>客户端</code>向<code>代理</code>服务器发送一个请求，并且指定<code>目标服务器</code>，之后<code>代理</code>向<code>目标服务器</code>转交并且将获得的内容返回给<code>客户端</code>。</p><p>  作用：</p><ul><li>访问本无法访问的服务器B</li><li>加速访问服务器B</li><li>Cache作用</li><li>客户端访问授权</li><li>隐藏访问者的行踪</li></ul></li><li><p>反向代理</p><p>  客户端不需要进行任何设置，<code>客户端</code>向<code>反向代理</code>发送请求，接着<code>反向代理</code>判断请求走向何处，发送请求，并将返回的响应转交给<code>客户端</code>，客户端并不会感知到反向代理后面的服务，使得这些内容就好似他自己响应的一样。</p><p>  作用：</p><ul><li>保护和隐藏原始资源服务器</li><li>加密和SSL加速</li><li>负载均衡</li><li>缓存静态内容</li><li>压缩</li><li>减速上传</li><li>安全</li><li>外网发布</li></ul></li></ul><h4 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h4><ul><li>GET 获取被请求 URI（Request-URI）指定的信息。</li><li>HEAD 不能在响应里返回消息主体，其响应里的元（头域）信息应该和 GET 请求响应里的元信息一致。</li><li>OPTIONS 请求想得到请求/响应链上关于此请求里的 URI（Request-URI）指定资源 的通信选项信息。</li><li>POST 用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物。</li><li>PUT 请求服务器去把请求里的实体存储在请求 URI（Request-URI）标识下，如果该资源已存在，则更新。</li><li>DELETE 请求源服务器删除请求 URI 指定的资源。</li><li>TRACE 被用于激发一个远程的、应用层的请求消息回路，不能包含一个实体。</li><li>CONNECT 被HTTP1.1 协议规范保留，为了能用于能动态切换到隧道的代理（如：SSL tunneling）。</li></ul><h4 id="HTTP-Code"><a href="#HTTP-Code" class="headerlink" title="HTTP Code"></a>HTTP Code</h4><p>HTTP 状态码</p><ol><li>1xx 消息</li><li>2xx 成功</li><li>3xx 重定向</li><li>4xx 客户端错误</li><li>5xx 服务器错误</li></ol><h4 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h4><h5 id="Cookie-用途"><a href="#Cookie-用途" class="headerlink" title="Cookie 用途:"></a>Cookie 用途:</h5><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>Web storage API （ localStorage 和 sessionStorage ）或 IndexedDB 。</p><p>创建Cookie:</p><p>服务器使用Set-Cookie响应头部向用户代理（User Agent）（一般是浏览器）发送Cookie信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</div></pre></td></tr></table></figure><p>之后，用户代理对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送给服务器。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 响应：设置cookie</div><div class="line">HTTP/1.0 200 OK</div><div class="line">Content-type: text/html</div><div class="line">Set-Cookie: yummy_cookie=choco</div><div class="line">Set-Cookie: tasty_cookie=strawberry</div><div class="line"></div><div class="line">[页面内容]</div><div class="line"></div><div class="line"># 之后的请求：发送cookie</div><div class="line">GET /sample_page.html HTTP/1.1</div><div class="line">Host: www.example.org</div><div class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</div></pre></td></tr></table></figure><h5 id="Cookie-类型："><a href="#Cookie-类型：" class="headerlink" title="Cookie 类型："></a>Cookie 类型：</h5><ul><li>会话期Cookie</li></ul><p>会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。</p><p>Max-Age: 单位是秒，优先级高于Expires</p><ul><li>持久性Cookie</li></ul><p>持久性Cookie，和关闭浏览器便失效的会话期Cookie不同，可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 会话期Cookie</div><div class="line">Set-Cookie: id=a3fWa;</div><div class="line"># 持久性Cookie。</div><div class="line">Set-Cookie: id=a3fWa; Max-Age=1000;</div><div class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</div></pre></td></tr></table></figure><h5 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h5><p>Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。</p><ul><li>Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。</li></ul><p>例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p><ul><li>Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</li></ul><p>例如，设置 Path=/docs，则以下地址都会匹配：</p><p>/docs<br>/docs/Web/<br>/docs/Web/HTTP</p><h5 id="Cookie-安全"><a href="#Cookie-安全" class="headerlink" title="Cookie 安全"></a>Cookie 安全</h5><p>Document.cookie属性可创建新的Cookie，获取<code>非HttpOnly</code>的Cookie。</p><ul><li>会话劫持和XSS</li><li>跨站请求伪造（CSRF）</li></ul><h4 id="HTTP-authourization"><a href="#HTTP-authourization" class="headerlink" title="HTTP authourization"></a>HTTP authourization</h4><h4 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h4><h5 id="Cache-目标"><a href="#Cache-目标" class="headerlink" title="Cache 目标"></a>Cache 目标</h5><p>重用已获取的资源。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存，HEAD请求也可以被缓存，但OPTIONS、POST、PUT、DELETE、TRACE都不可以被缓存，CONNECT方法不具备可缓存cacheable的特性）。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache Control"></a>Cache Control</h5><p>HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><p>Cache-Control的可能取值:</p><ul><li>private 默认值。表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</li><li>public 表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。</li><li>no-cache 此方式下，每次有请求发出时，缓存会将此请求发到服务器，服务器端会验证请求中相关验证字段所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本。</li><li>no-store 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</li><li>must-revalidate 缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。</li></ul><h5 id="Cache-校验"><a href="#Cache-校验" class="headerlink" title="Cache 校验"></a>Cache 校验</h5><ul><li>ETag/If-None-Match 强校验器</li><li>Last-Modified/If-Modified-Since 弱校验器</li><li>Vary 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>与HTTP/1.x主要的区别：</p><ol><li>二进制的，而不是文本的；（is binary, instead of textual）</li><li>是完全多路复用的，而不是按序和阻塞的；（is fully multiplexed, instead of ordered and blocking）</li><li>能用一个（TCP）连接来实现并行（请求）；（can therefore use one connection for parallelism）</li><li>压缩头部（header），来减少开销；（uses header compression to reduce overhead）</li><li>允许服务器主动地将响应“推”到客户端缓存中。（allows servers to “push” responses proactively into client caches）</li></ol><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://tools.ietf.org/html/rfc2616#page-51" target="_blank" rel="external">rfc2616 HTTP/1.1</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="external">HTTP MDN</a></li><li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="external">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></li><li><p><a href="https://http2.github.io/faq/" target="_blank" rel="external">HTTP/2</a></p></li><li><p><a href="https://www.jianshu.com/p/208c02c9dd1d" target="_blank" rel="external">正向代理与反向代理的区别</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web前端涉及到的相关网络协议概述。（待完善）&lt;/p&gt;
&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;HTTP（HyperText Transfer Protoco
      
    
    </summary>
    
      <category term="Network Protocol" scheme="http://ssdna.github.io/categories/Network-Protocol/"/>
    
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://ssdna.github.io/tags/HTTPS/"/>
    
      <category term="Websocket" scheme="http://ssdna.github.io/tags/Websocket/"/>
    
      <category term="Cache" scheme="http://ssdna.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>js实现继承的6种方式</title>
    <link href="http://ssdna.github.io/2018/04/21/6-Ways-to-Implement-JS-Inheritance/"/>
    <id>http://ssdna.github.io/2018/04/21/6-Ways-to-Implement-JS-Inheritance/</id>
    <published>2018-04-21T11:17:35.000Z</published>
    <updated>2018-04-21T11:55:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结自<code>js高程</code>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Super</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Sub</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.getSubProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1 <span class="keyword">instanceof</span> SuperType === <span class="literal">true</span>; <span class="comment">// true</span></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">instance2.property === instance1.property; <span class="comment">// true</span></div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>父类SuperType实例上的属性和方法 和 SuperType原型上的属性和方法，都会被子类SubType继承；</li></ol></li><li><p>缺点：</p><ol><li>子类SubType所有实例共享 <code>一个SuperType的实例</code>，该实例原型上的属性，一个被修改，所有的子类SubType实例都会被修改；</li><li>无法为父类SuperType的构造函数传递参数。</li></ol></li></ul><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Super</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Sub</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'wn'</span>, <span class="number">12</span>);</div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'fyt'</span>, <span class="number">11</span>);</div><div class="line">instance1.color.push(<span class="string">'xxx'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1, instance2);</div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>可以为父类SuperType的构造函数传递参数。</li></ol></li><li><p>缺点：</p><ol><li>无法复用父类SubType上的函数，每个子类SubType的实例，都会创建一个同名的函数。</li></ol></li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Super</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Sub</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'wn'</span>, <span class="number">12</span>);</div><div class="line">instance1.color.push(<span class="string">'xxx'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.getName());</div><div class="line"><span class="built_in">console</span>.log(instance1.getAge());</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'fyt'</span>, <span class="number">11</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.getName());</div><div class="line"><span class="built_in">console</span>.log(instance2.getAge());</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(instance1, instance2);</div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>可以复用父类SuperType原型上的函数。</li><li>可以为父类SuperType的构造函数传递参数。</li></ol></li><li><p>缺点：</p><ol><li>SuperType 需要 new 两次</li></ol></li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Object.create() 等价</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = object(person); anotherPerson.name = <span class="string">"Greg"</span>; anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person); yetAnotherPerson.name = <span class="string">"Linda"</span>; yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.friends);</div><div class="line"></div><div class="line"><span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>可以直接为一个对象（实例）扩展一个新对象。</li></ol></li><li><p>缺点：</p><ol><li>简单把对象放在新函数的原型上，不涉及到SuperType类及其构造函数初始化。</li></ol></li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    <span class="comment">// 增强对象</span></div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>可以直接为一个对象（实例）扩展（或增强）一个新对象。</li></ol></li><li><p>缺点：</p><ol><li>简单把对象放在新函数的原型上，不涉及到SuperType类及其构造函数初始化。</li></ol></li></ul><h3 id="寄生组合式"><a href="#寄生组合式" class="headerlink" title="寄生组合式"></a>寄生组合式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// inheritPrototype</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">subType, superType</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// swallow clone</span></div><div class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);</div><div class="line">    prototype.constructor = subType;</div><div class="line">    subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Super</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Sub</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line"><span class="comment">// inheritPrototype函数实现内容，如上：</span></div><div class="line"><span class="comment">// var prototype = object(SuperType.prototype);</span></div><div class="line"><span class="comment">// prototype.constructor = SubType;</span></div><div class="line"><span class="comment">// SubType.prototype = prototype;</span></div><div class="line"></div><div class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'wn'</span>, <span class="number">12</span>);</div><div class="line">instance1.color.push(<span class="string">'xxx'</span>);</div><div class="line"><span class="built_in">console</span>.log(instance1.getName());</div><div class="line"><span class="built_in">console</span>.log(instance1.getAge());</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'fyt'</span>, <span class="number">11</span>);</div><div class="line"><span class="built_in">console</span>.log(instance2.getName());</div><div class="line"><span class="built_in">console</span>.log(instance2.getAge());</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(instance1, instance2);</div></pre></td></tr></table></figure><ul><li><p>优点：</p><ol><li>完美。</li></ol></li><li><p>缺点：</p><ol><li>完美。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结自&lt;code&gt;js高程&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端基础知识复习之CSS</title>
    <link href="http://ssdna.github.io/2017/11/13/Review-of-Front-End-CSS/"/>
    <id>http://ssdna.github.io/2017/11/13/Review-of-Front-End-CSS/</id>
    <published>2017-11-13T12:57:38.000Z</published>
    <updated>2017-11-13T15:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="居中问题"><a href="#居中问题" class="headerlink" title="居中问题"></a>居中问题</h2><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 文字行 水平居中对齐，如p、h1-h6 */</span></div><div class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</div><div class="line"><span class="comment">/* 文字块 水平居中对齐 */</span></div><div class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">auto</span>;</div><div class="line"><span class="selector-tag">margin-right</span>: <span class="selector-tag">auto</span>;</div><div class="line"><span class="comment">/* 文字行和列 垂直居中对齐，需要指定高度，如height、line-height或min-height等 */</span></div><div class="line"><span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>;</div></pre></td></tr></table></figure><h3 id="CSS-level-3-居中"><a href="#CSS-level-3-居中" class="headerlink" title="CSS level 3 居中"></a>CSS level 3 居中</h3><ul><li>水平+垂直居中一体：外层relative，内层absolute+top+transform。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10em</span>;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">margin-right</span>: -<span class="number">50%</span>; <span class="comment">/* 注意这里的margin-right! 用来补偿'left:50%'造成的可用元素宽度减少的50%。 详见链接中网页最下方：https://www.w3.org/Style/Examples/007/center.zh_CN.html */</span></div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>水平+垂直居中：flex。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10em</span>;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="comment">/* 垂直方向 */</span></div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">    <span class="comment">/* 水平方向 */</span></div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相关资料：</p><ul><li><a href="https://www.w3.org/Style/Examples/007/center.zh_CN.html" target="_blank" rel="external">https://www.w3.org/Style/Examples/007/center.zh_CN.html</a></li></ul><h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><ul><li>Flex Container</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">display: flex | inline-flex;</div><div class="line">flex-direction: row | row-reverse | column | column-reverse;</div><div class="line">flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;;</div><div class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</div><div class="line">align-items: flex-start | flex-end | center | baseline | stretch;</div><div class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</div></pre></td></tr></table></figure><ul><li>Flex Item</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">order</span>: &lt;<span class="selector-tag">integer</span>&gt;;</div><div class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt; (<span class="selector-tag">default</span><span class="selector-pseudo">:0)</span>;</div><div class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt; (<span class="selector-tag">default</span><span class="selector-pseudo">:1)</span>;</div><div class="line">flex-basis: &lt;length&gt; | auto (default:auto);</div><div class="line">flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ];</div><div class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</div></pre></td></tr></table></figure><p>相关资料：</p><ul><li><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox.html" target="_blank" rel="external">http://www.w3cplus.com/css3/a-guide-to-flexbox.html</a></li></ul><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><ul><li>屏幕</li></ul><p>单位px，在低分辨率的设备上为1像素，在高分辨率设备上大约为1英尺的1/96。</p><blockquote><p>1in = 96px</p></blockquote><ul><li>打印机</li></ul><blockquote><p>1in = 2.54cm = 25.4mm = 72pt = 6pc</p></blockquote><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><h4 id="字体相对单位"><a href="#字体相对单位" class="headerlink" title="字体相对单位"></a>字体相对单位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">em: 该元素计算后的字体大小</div><div class="line">rem: 文件的根元素(html)的字体大小</div><div class="line">ch: 0的字体宽度。</div><div class="line">ex: 小写字母x的字体高度，1ex约为0.5em</div></pre></td></tr></table></figure><h4 id="视口百分比长度"><a href="#视口百分比长度" class="headerlink" title="视口百分比长度"></a>视口百分比长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vw: 容器块视口1%的宽度</div><div class="line">vh: 容器块视口1%的高度</div><div class="line">vmin: vw和vh中最小的</div><div class="line">vmax: vw和vh中最大的</div></pre></td></tr></table></figure><p>相关资料：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/length" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/CSS/length</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;居中问题&quot;&gt;&lt;a href=&quot;#居中问题&quot; class=&quot;headerlink&quot; title=&quot;居中问题&quot;&gt;&lt;/a&gt;居中问题&lt;/h2&gt;&lt;h3 id=&quot;文本居中&quot;&gt;&lt;a href=&quot;#文本居中&quot; class=&quot;headerlink&quot; title=&quot;文本居中&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://ssdna.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Server-sent Events学习记录</title>
    <link href="http://ssdna.github.io/2017/10/26/A-note-of-Server-sent-Events/"/>
    <id>http://ssdna.github.io/2017/10/26/A-note-of-Server-sent-Events/</id>
    <published>2017-10-26T11:29:20.000Z</published>
    <updated>2018-04-21T10:50:05.471Z</updated>
    
    <content type="html"><![CDATA[<p>服务器推送事件（Server-sent Events，简称<code>SSE</code>，下同）是<a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model" target="_blank" rel="external">HTML5规范</a>中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于WebSocket技术来说，SSE只是单向通信（只能实现服务器向浏览器推送消息，而浏览器不能通过sse向服务器主动发送消息），使用起来也更加简单，对服务器端的改动也比较小，特别适合于诸如监控数据、消息推送等应用场景。</p><a id="more"></a><h2 id="SSE简述"><a href="#SSE简述" class="headerlink" title="SSE简述"></a>SSE简述</h2><p>Server-sent Events比较简单，主要由<strong>两个部分</strong>组成：</p><ol><li>第一个部分是服务器端与浏览器端之间的<code>通讯协议</code>（基于纯文本）；</li><li>第二部分则是在浏览器端可供 JavaScript 使用的 <code>EventSource</code> 对象。</li></ol><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>这里详细介绍SSE的通信协议。</p><ul><li>SSE的通讯协议是基于<code>纯文本</code>的简单协议，即服务端和浏览器之间采用纯文本进行通信。</li><li>服务器端响应的头部信息（内容类型）<code>Content-Type</code>必须是<code>text/event-stream</code>。</li><li>响应文本的内容可以看成是一个事件流（<code>Event stream</code>），由不同的事件所组成。</li><li>事件流（<code>Event stream</code>）强制使用UTF8编码，且无法修改编码方式;</li><li>每个事件由<code>类型(event)</code>和<code>数据(data)</code>两部分组成，同时每个事件可以有一个可选的<code>标识符(id)</code>。</li><li>事件流中每行的结尾可以是<code>CRLF</code>、<code>LF</code>、<code>CR</code>三者中的任意一个。（<code>CRLF</code>是Carriage-Return Line-Feed的缩写，意思是回车换行，就是回车(<code>CR</code>, ASCII 13, <code>\r</code>) 与换行(<code>LF</code>, ASCII 10, <code>\n</code>)）</li><li>每个事件的数据可能由多行组成，每个事件之间通过额外的空行（<code>CRLF</code>、<code>LF</code>、<code>CR</code>三者中的任意一个）来分隔。</li><li>对于每一行来说，冒号（<code>:</code>）前面表示的是该行的类型，冒号后面则是对应的值（可以为空）。其事件类型如下：</li></ul><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><p>SSE的事件类型可分为五类。</p><ol><li><p>类型为 空白，表示该行是注释，会在处理时被忽略。举例如下：</p><ul><li>空白注释<blockquote><p>:</p></blockquote></li><li>带描述的注释<blockquote><p>:this is a commont</p></blockquote></li></ul></li><li><p>类型为 data，表示该行包含的是数据。以data开头的行可以连续出现多次，所有这些行都是该事件的数据。多行data最终的数据每行与每行中间都有一个<code>\n</code>，但最后没有<code>\n</code>。举例如下：</p><ul><li>单行data，最终data为：”sse event”<blockquote><p>data:sse event</p></blockquote></li><li>多行data，最终data为：”AAAA\nBBBB”<blockquote><p>data: AAAA<br>data:BBBB</p></blockquote></li></ul></li><li><p>类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。举例如下：</p><ul><li>自定义myevnet，可触发<code>source.addEventListener(&#39;myevent&#39;, (event) =&gt; {console.log(event.data)})</code>。其中，<code>event.data===&#39;my event data\ncontinue&#39;</code><blockquote><p>event: myevent<br>data: my event data<br>data:continue</p></blockquote></li></ul></li><li><p>类型为 id，表示该行用来声明事件的标识符（整数字符串）。标识符id主要用在尝试重连的请求头<code>Last-Event-ID</code>字段中，给服务器提供信息。举例如下：</p><ul><li>指定标识符id，如果此时断开连接，下次重连时的请求头中会自动将’30’放在<code>Last-Event-ID</code>字段中，服务器可以根据这个请求头字段做特定的处理。<blockquote><p>id: 30<br>data: dddd</p></blockquote></li></ul></li><li><p>类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间（毫秒数），服务器可以动态调节推送频率。</p><ul><li>指定下次重连时间为3000ms，可动态变化<blockquote><p>retry: 3000</p></blockquote></li></ul></li></ol><h4 id="事件数据"><a href="#事件数据" class="headerlink" title="事件数据"></a>事件数据</h4><p>服务器端响应内容的示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data: first event</div><div class="line"></div><div class="line">data: second event</div><div class="line">id: 100</div><div class="line"></div><div class="line">event: myevent</div><div class="line">data: third event</div><div class="line">retry: 3000</div><div class="line">id: 101</div><div class="line"></div><div class="line">: this is a comment，注意最后一行的多余空行</div><div class="line">data: fourth event</div><div class="line">data: fourth event continue</div></pre></td></tr></table></figure><h4 id="相关HTTP-header"><a href="#相关HTTP-header" class="headerlink" title="相关HTTP header"></a>相关HTTP header</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 响应头</div><div class="line">Content-Type:text/event-stream;</div><div class="line">Cache-Control:no-cache</div><div class="line">// 请求头（只有在SSE重连时，浏览器端才会找到上一个合法的id，并通过以下请求头字段发送给服务器）</div><div class="line">Last-Event-ID:2</div></pre></td></tr></table></figure><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul><li>Event stream请求可以通过HTTP状态码301和307进行重定向；</li><li>当连接关闭时，浏览器会尝试自动重连，除非收到HTTP状态吗204（No Content）；</li><li>Event stream中，冒号（<code>:</code>）可以在行首表示改行是注释；</li><li>Event stream中，非注释行冒号（<code>:</code>）后可以有一个空格，该空格不会计入data buffer中；</li><li>Event stream中，最后一行如果没有额外的空行，会导致最后一个事件推送不成功；</li><li>对于代理服务器，因其在特定情况下会在短暂的延时后断开HTTP连接，设计者可以考虑每隔15s推送一条注释消息；</li><li>在SSE重连时，浏览器端会找到上一个合法的id，跳过那些没有设置id的事件，并通过Last-Event-ID请求头字段发送给服务器；如果上一条id为空，则表示清空last event ID string，这种情况下，浏览器重连时并不会发送Last-Event-ID请求头字段。</li></ul><h3 id="Event-Source对象"><a href="#Event-Source对象" class="headerlink" title="Event Source对象"></a>Event Source对象</h3><p>Event Source对象有4个要点，其中后3个都不暴露在Event Source对象上：</p><ol><li>url；</li><li>请求；</li><li>重连事件；</li><li>last event ID string；</li></ol><p>Event Source对象有如下API接口：</p><ul><li>url (read-only);</li><li>withCredentials (read-only);</li><li>readyState // CONNECTING (0), OPEN (1), CLOSED (2)</li><li>EventHandler // onopen, onmessage, onerror</li><li>close (void)</li></ul><h2 id="具体实现方案"><a href="#具体实现方案" class="headerlink" title="具体实现方案"></a>具体实现方案</h2><h3 id="Browser端"><a href="#Browser端" class="headerlink" title="Browser端"></a>Browser端</h3><p>目前，除IE外，几乎所有的浏览器都支持sse，即window下有EventSource属性（对象）。对于IE可以使用简易轮询或<code>COMET</code>技术来实现，也可以使用<a href="https://github.com/Yaffle/EventSource" target="_blank" rel="external">polyfill</a>。</p><p>下图是我在<a href="http://caniuse.com/#search=EventSource" target="_blank" rel="external">Can I use</a>上针对SSE于2017年10月26日的查询结果:<br><img src="Can-I-use-sse.png" alt="Can I use sse"></p><ul><li>具体实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// constructor. When invoked, must init env &amp; fetch request</span></div><div class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost/sse.php'</span>);</div><div class="line"><span class="comment">// onmessage. Also: 'onopen', 'onerror'</span></div><div class="line">source.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// custom event listener. Also: 'open', 'message', 'error'</span></div><div class="line">source.addEventListener(<span class="string">'event1'</span>, event =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><h4 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h4><h5 id="1-简单版"><a href="#1-简单版" class="headerlink" title="1. 简单版"></a>1. 简单版</h5><p>鄙人常用的后台语言是PHP，网上对PHP实现SSE的大部分实现方法<a href="http://www.w3school.com.cn/html5/html_5_serversentevents.asp" target="_blank" rel="external">如下</a>（来自w3cshool）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 简单版</span></div><div class="line"><span class="comment"> * http://www.w3school.com.cn/html5/html_5_serversentevents.asp</span></div><div class="line"><span class="comment"> */</span></div><div class="line">header(<span class="string">'Content-Type: text/event-stream'</span>);</div><div class="line">header(<span class="string">'Cache-Control: no-cache'</span>);</div><div class="line"></div><div class="line">date_default_timezone_set(<span class="string">'UTC'</span>);</div><div class="line">$time = date(<span class="string">'r'</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">"event: event1\n"</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>;</div><div class="line">flush();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>经测试，上述简单版的PHP代码虽然能实现推送的功能，但这种写法实际上的效果其实跟轮询差不多。之所以这么讲，是因为从chrome开发调试工具的Network里可以看到间歇性的多条类型为eventsource的请求，如下图示。</p><img src="/images/sse/network-console.png" width="500" height="450" title="Network Console"><img src="/images/sse/network-eventstream.png" width="500" height="450" title="Network Eventstream"><p>这是因为浏览器上的EventSource实例默认会自动重连。上述PHP代码实际上只是一个HTTP短连接，只提供一次简短的sse推送。正是由于自动重连的存在，所以每次短暂的sse推送之后，每隔一段时间便会有一次重连再获取一次新的简短的sse推送。</p><h5 id="2-while-true-版"><a href="#2-while-true-版" class="headerlink" title="2. while(true)版"></a>2. while(true)版</h5><p>另一种实现方法是<code>while(true)</code>的写法，虽然又会造成服务器端资源的浪费（例如HTTP长连接等）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * while(true)版</span></div><div class="line"><span class="comment"> */</span></div><div class="line">header(<span class="string">'Content-Type: text/event-stream'</span>); </div><div class="line">header(<span class="string">'Cache-Control: no-cache'</span>); </div><div class="line"></div><div class="line">date_default_timezone_set(<span class="string">'UTC'</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    $time = date(<span class="string">'r'</span>); </div><div class="line">    <span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>; </div><div class="line">    ob_flush();</div><div class="line">    flush(); </div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><img src="/images/sse/network-console-while-true.png" width="500" height="450" title="Network Eventstream"><h5 id="3-终极版"><a href="#3-终极版" class="headerlink" title="3. 终极版"></a>3. 终极版</h5><p>改进的方法是定时或定次（推送事件的次数）服务器端主动断开HTTP长连接，并根据每次推送事件的id（last-evnet-id）来在再次重连的时候恢复推送记录。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 改进版，会定时断开长连接，并能根据last event id恢复</span></div><div class="line"><span class="comment"> * https://github.com/Yaffle/EventSource</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">  header(<span class="string">"Content-Type: text/event-stream"</span>);</div><div class="line">  header(<span class="string">"Cache-Control: no-store"</span>);</div><div class="line">  header(<span class="string">"Access-Control-Allow-Origin: *"</span>);</div><div class="line"></div><div class="line">  $lastEventId = floatval(<span class="keyword">isset</span>($_SERVER[<span class="string">"HTTP_LAST_EVENT_ID"</span>]) ? $_SERVER[<span class="string">"HTTP_LAST_EVENT_ID"</span>] : <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> ($lastEventId == <span class="number">0</span>) &#123;</div><div class="line">    $lastEventId = floatval(<span class="keyword">isset</span>($_GET[<span class="string">"lastEventId"</span>]) ? $_GET[<span class="string">"lastEventId"</span>] : <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">echo</span> <span class="string">"retry: 2000\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// event-stream</span></div><div class="line">  $i = $lastEventId;</div><div class="line">  $c = $i + <span class="number">100</span>;</div><div class="line">  <span class="keyword">while</span> (++$i &lt; $c) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"id: "</span> . $i . <span class="string">"\n"</span>;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"data: "</span> . $i . <span class="string">";\n\n"</span>;</div><div class="line">    ob_flush();</div><div class="line">    flush();</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h4 id="nodejs实现"><a href="#nodejs实现" class="headerlink" title="nodejs实现"></a>nodejs实现</h4><p>这里使用node自带的http库来实现，简单添加了允许所有域跨域请求的请求头，随机推送一个事件，并且会定次（100次）断开长连接，并能根据last event id恢复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="comment">// options</span></div><div class="line"><span class="keyword">const</span> options = &#123;</div><div class="line">    port: <span class="number">3003</span>,</div><div class="line">    intervalTime: <span class="number">3000</span>,</div><div class="line">    interval: <span class="literal">null</span>,</div><div class="line">    events: [<span class="string">'connected'</span>, <span class="string">'event1'</span>, <span class="string">'event2'</span>, <span class="string">'event3'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 会定次断开长连接，并能根据last event id恢复</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// headers of SSE(Server-sent Events) &amp; CORS(Cross Origin Resources Sharing)</span></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span>,</div><div class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</div><div class="line">        <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// SSE stream</span></div><div class="line">    response.write(<span class="string">`retry: <span class="subst">$&#123;options.interValTime&#125;</span>\n`</span>);</div><div class="line">    response.write(<span class="string">`event: <span class="subst">$&#123;options.events[<span class="number">0</span>]&#125;</span>\n`</span>);</div><div class="line">    response.write(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()&#125;</span>\n\n`</span>);</div><div class="line">    <span class="comment">// last event id</span></div><div class="line">    <span class="keyword">let</span> lastEventId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (request.headers[<span class="string">"last-event-id"</span>] !== <span class="literal">undefined</span>) &#123;</div><div class="line">        lastEventId = <span class="built_in">Number</span>(request.headers[<span class="string">"last-event-id"</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> i = lastEventId;</div><div class="line">    <span class="keyword">let</span> c = i + <span class="number">100</span>;</div><div class="line">    <span class="comment">// timeout function</span></div><div class="line">    <span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (++i &lt; c) &#123;</div><div class="line">        <span class="comment">// send events randomly</span></div><div class="line">        <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>) + <span class="number">1</span>;</div><div class="line">        response.write(<span class="string">`id: <span class="subst">$&#123;i&#125;</span>\n`</span>);</div><div class="line">        response.write(<span class="string">`event: <span class="subst">$&#123;options.events[index]&#125;</span>\n`</span>);</div><div class="line">        response.write(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()&#125;</span>\n\n`</span>);</div><div class="line">        options.interval = setTimeout(fun, options.intervalTime);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        response.end();</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    fun();</div><div class="line"></div><div class="line">    <span class="comment">// close</span></div><div class="line">    request.connection.addListener(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'sse server closing...[browser side close]'</span>);</div><div class="line">        clearInterval(options.interval);</div><div class="line">        response.end();</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">&#125;)</div><div class="line">server.listen(options.port);</div></pre></td></tr></table></figure><p>以上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model" target="_blank" rel="external">HTML Specification</a>（强烈建议仔细研读）</li><li><a href="https://github.com/Yaffle/EventSource" target="_blank" rel="external">EventSource polyfill</a>（支持IE的polyfill）</li><li><a href="https://www.ibm.com/developerworks/cn/web/1307_chengfu_serversentevent/" target="_blank" rel="external">HTML5 服务器推送事件（Server-sent Events）实战开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器推送事件（Server-sent Events，简称&lt;code&gt;SSE&lt;/code&gt;，下同）是&lt;a href=&quot;https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTML5规范&lt;/a&gt;中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于WebSocket技术来说，SSE只是单向通信（只能实现服务器向浏览器推送消息，而浏览器不能通过sse向服务器主动发送消息），使用起来也更加简单，对服务器端的改动也比较小，特别适合于诸如监控数据、消息推送等应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://ssdna.github.io/categories/HTML5/"/>
    
    
      <category term="SSE" scheme="http://ssdna.github.io/tags/SSE/"/>
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="PHP" scheme="http://ssdna.github.io/tags/PHP/"/>
    
      <category term="nodejs" scheme="http://ssdna.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API设计总结</title>
    <link href="http://ssdna.github.io/2017/09/29/A-Note-of-RESTful-API-Design/"/>
    <id>http://ssdna.github.io/2017/09/29/A-Note-of-RESTful-API-Design/</id>
    <published>2017-09-29T02:37:32.000Z</published>
    <updated>2017-10-09T10:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是<code>ThinkPHP5</code>，前端部分用的是<code>vue2+vue-router+vuex</code>的全家桶，用<code>axios</code>进行数据交互。这里总结一下对RESTful API的学习和设计心得。</p><a id="more"></a><h3 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h3><p>RESTful（Representational State Transfer，表现层状态转移）是一种软件架构风格，主要用于客户端（包括浏览器）与服务器端进行数据交互的场景。一个好的RESTful API设计，可以让服务器端只实现一套API接口，就能同时为Web应用、移动端、电脑端同时提供更简洁，更有层次，更易于实现缓存的服务。</p><h3 id="RESTful设计举例"><a href="#RESTful设计举例" class="headerlink" title="RESTful设计举例"></a>RESTful设计举例</h3><p><a href="">知乎</a>上对RESTful API有一条言简意赅的解释：</p><blockquote><p>看<code>url</code>就知道要什么，看<code>http method</code>就知道干什么，看<code>http status code</code>就知道结果如何。</p></blockquote><p>举个例子：如果拿课程(course)作为一个资源，对其进行符合RESTful的API接口设计，其url一般可以设计成如下格式：</p><ul><li>获取课程资源列表<br>[GET] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程资源<br>[GET] <code>http://api.hostname.com/v1/courses/id</code></li><li>新建课程资源<br>[POST] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（全部）<br>[PUT] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（部分）<br>[PATCH] <code>http://api.hostname.com/v1/courses</code></li><li>删除课程资源<br>[DELETE] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程下的实验资源列表<br>[GET] <code>http://api.hostname.com/v1/courses/id/experiments</code></li><li>获取课程资源列表（分页查询）<br>[GET] <code>http://api.hostname.com/v1/courses?query=&amp;page=2&amp;per_page=100</code></li></ul><p>由上述例子可以看出，RESTful用<code>url</code>来表示一个资源（列表），用<code>HTTP method</code>来表示对资源的增删改查，用<code>http请求参数</code>来对访问的资源作进一步限定。一些实际应用中公认的设计优良的的RESTful API可以参考<a href="">github</a>和<a href="">leancloud</a>。</p><h3 id="RESTful设计准则"><a href="#RESTful设计准则" class="headerlink" title="RESTful设计准则"></a>RESTful设计准则</h3><p>按上述几个方面划分，RESTful设计需要符合如下准则：</p><h4 id="一、url"><a href="#一、url" class="headerlink" title="一、url"></a>一、url</h4><p>RESTful架构中的url代表的是一个资源。url一般需要符合如下要求：</p><ol><li>url中最好加入API的<strong>版本号</strong>信息；</li><li>url中尽量用<strong>名词</strong>表示资源；</li><li>url中尽量用名词的<strong>复数</strong>；</li><li>url中一般会加入可选的<strong>参数</strong>（如<code>id</code>），表示对资源限制条件；</li><li>url中可按需加入过滤信息（如<code>?q=&amp;page=2&amp;per_page=100</code>、<code>?sortby=name&amp;order=asc</code>、<code>?type=1</code>等）；</li></ol><h4 id="二、http-method"><a href="#二、http-method" class="headerlink" title="二、http method"></a>二、http method</h4><p>RESTful中用到的http method如下：</p><ul><li>// 常用</li><li>GET     (SELECT)    ：获出资源（一项或多项）。</li><li>POST    (CREATE)    ：新建一个资源。</li><li>PUT     (UPDATE)    ：更新资源（客户端提供改变后的完整资源）。</li><li>PATCH   (UPDATE)    ：更新资源（客户端只提供待改变部分的属性）。</li><li>DELETE  (DELETE)    ：删除资源。</li><li>// 不常用</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h4 id="三、http-status-code"><a href="#三、http-status-code" class="headerlink" title="三、http status code"></a>三、http status code</h4><p>RESTful API返回的响应结果中，其<strong>http状态码</strong>应该按照http规范对响应结果的状态进行表示。常见的状态码与提示信息如下：</p><ul><li>200 OK                      – [GET] 操作成功</li><li>201 CREATED                 – [POST/PUT/PATCH] 新建/修改数据成功</li><li>204 NO CONTENT              – [DELETE] 删除数据成功</li><li>400 INVALID REQUEST         – [POST/PUT/PATCH] 请求的数据有误</li><li>404 NOT FOUND               – [*] 资源不存在</li><li>500 INTERNAL SERVER ERROR   – [*] 服务器发生错误</li></ul><h4 id="四、other"><a href="#四、other" class="headerlink" title="四、other"></a>四、other</h4><ol><li>对于4xx的错误情况，需要将错误的信息返回，比如<code>{&quot;error&quot;:&quot;没有权限！&quot;}</code>；</li><li>返回的结果尽量使用<strong>json</strong>格式；</li><li>最好添加身份验证，如<code>OAuth 2.0</code>，或<code>api_key</code>;</li><li>最好做到<strong>Hypermedia</strong>，即在返回结果中提供指向该API的说明文档链接或其他相关API的链接。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是&lt;code&gt;ThinkPHP5&lt;/code&gt;，前端部分用的是&lt;code&gt;vue2+vue-router+vuex&lt;/code&gt;的全家桶，用&lt;code&gt;axios&lt;/code&gt;进行数据交互。这里总结一下对RESTful API的学习和设计心得。&lt;/p&gt;
    
    </summary>
    
      <category term="RESTful" scheme="http://ssdna.github.io/categories/RESTful/"/>
    
    
      <category term="RESTful" scheme="http://ssdna.github.io/tags/RESTful/"/>
    
      <category term="API" scheme="http://ssdna.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享技术总结</title>
    <link href="http://ssdna.github.io/2017/09/28/A-Note-of-CORS/"/>
    <id>http://ssdna.github.io/2017/09/28/A-Note-of-CORS/</id>
    <published>2017-09-28T13:25:21.000Z</published>
    <updated>2017-10-26T10:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨域资源共享，即Cross-origin Resource Sharing（下称<code>CORS</code>），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。</p><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><p>浏览器的同源策略</p><h3 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h3><p>An origin is defined by the scheme, host, and port of a URL.</p><p>### </p><p>## </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域资源共享，即Cross-origin Resource Sharing（下称&lt;code&gt;CORS&lt;/code&gt;），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的同源策略&quot;&gt;&lt;a href=&quot;#浏览器的同源策略&quot; class=&quot;headerlink&quot; title=&quot;浏览器的同源策略&quot;&gt;&lt;/a&gt;浏览器的同源策略&lt;/h2&gt;&lt;p&gt;浏览器的同源策略&lt;/p&gt;
&lt;h3 id=&quot;源的定义&quot;&gt;&lt;a href=&quot;#源的定义&quot; class=&quot;headerlink&quot; title=&quot;源的定义&quot;&gt;&lt;/a&gt;源的定义&lt;/h3&gt;&lt;p&gt;An origin is defined by the scheme, host, and port of a URL.&lt;/p&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://ssdna.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="Browser" scheme="http://ssdna.github.io/tags/Browser/"/>
    
      <category term="ThinkPHP" scheme="http://ssdna.github.io/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>js小技巧之----获取窗口resize完成之后的事件</title>
    <link href="http://ssdna.github.io/2016/07/31/Simulate-onresized-Event-by-Using-settimeout/"/>
    <id>http://ssdna.github.io/2016/07/31/Simulate-onresized-Event-by-Using-settimeout/</id>
    <published>2016-07-30T16:46:31.000Z</published>
    <updated>2017-10-09T10:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>用js可以方便地获取浏览器窗口<code>onResize</code>事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(<code>onResizeCompleted</code>)却比较麻烦。</p><a id="more"></a><h2 id="获取onResize事件"><a href="#获取onResize事件" class="headerlink" title="获取onResize事件"></a>获取<code>onResize</code>事件</h2><h3 id="js原生代码"><a href="#js原生代码" class="headerlink" title="js原生代码"></a>js原生代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth + <span class="string">' '</span> + <span class="built_in">window</span>.innerHeight);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="JQuery代码"><a href="#JQuery代码" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log($(<span class="built_in">window</span>).width() + <span class="string">' '</span> + $(<span class="built_in">window</span>).height());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>上面的代码，可以使浏览器在resize的时候在控制台console实时输出当前页面的长、宽像素。这里就不贴图了，可以看到随着鼠标对浏览器窗口的拖动(onResize)时，console里有很多的数据在实时输出。也就是说，上面的函数在resize的时候执行了很多次！</p><p>那么问题来了：如果我想只想监听浏览器窗口resize结束的事件该怎么做呢？也就是说，如果我只想让一个函数在浏览器窗口resize结束之后只执行一次，而不是一直执行，该怎么做呢？</p><h2 id="获取onResizeCompleted事件"><a href="#获取onResizeCompleted事件" class="headerlink" title="获取onResizeCompleted事件"></a>获取<code>onResizeCompleted</code>事件</h2><h3 id="js原生代码-1"><a href="#js原生代码-1" class="headerlink" title="js原生代码"></a>js原生代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">clearTimeout(resizeTimer);</div><div class="line">resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// 此函数会在resize结束的时候执行</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">&#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="JQuery代码-1"><a href="#JQuery代码-1" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  clearTimeout(resizeTimer);</div><div class="line">  resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 此函数在resize结束的时候执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">  &#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里利用setTimeout()函数配合对应的clearTimeout()函数不断被执行，实现了简单的计时器Timer，当resize事件触发后停下来的250ms时间后，执行内部的匿名函数，模拟实现对<code>onResizeCompleted</code>事件的监听。当然，这里的250ms可以根据实际的需求进行自己的设定，不过已经符合大部分的情况了，我在noVNC里也见到过同样的设定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种小技巧，可能会在处理别的类似的事件的时候会有用，有待验证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用js可以方便地获取浏览器窗口&lt;code&gt;onResize&lt;/code&gt;事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(&lt;code&gt;onResizeCompleted&lt;/code&gt;)却比较麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="Event" scheme="http://ssdna.github.io/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>用js弹出浏览器自定义精简窗口</title>
    <link href="http://ssdna.github.io/2016/07/30/Open-and-Control-a-customized-Window-in-Browser/"/>
    <id>http://ssdna.github.io/2016/07/30/Open-and-Control-a-customized-Window-in-Browser/</id>
    <published>2016-07-30T15:28:30.000Z</published>
    <updated>2017-10-09T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。<br><a id="more"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以调用如下的函数控制浏览器弹出自定义精简窗口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义新窗口相关的变量</span></div><div class="line"><span class="keyword">var</span> newWindow = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> newWindowName = <span class="string">"new_window"</span>;</div><div class="line"><span class="keyword">var</span> newWindowFeature = <span class="string">"resizable=yes, scrollbars=yes, left=200, top=100, width=600, height=400"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">popUpSimpleWindow</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 判断该窗口是否已经打开</span></div><div class="line"><span class="keyword">if</span>(newWindow == <span class="literal">null</span> || newWindow.closed) &#123;</div><div class="line"><span class="comment">// 打开上述自定义特性的窗口</span></div><div class="line">newWindow = <span class="built_in">window</span>.open(<span class="string">"http://nucNaOH.github.io"</span>, newWindowName, newWindowFeature);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">newWindow.focus();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">popUpSimpleWindow();</div></pre></td></tr></table></figure></p><p>效果如下图：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E7%B2%BE%E7%AE%80%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3.png" alt="精简窗口"></p><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><p>关键的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newWindow = <span class="built_in">window</span>.open(url, newWindowName, newWindowFeature);</div></pre></td></tr></table></figure></p><p>该函数的有三个参数，分别为新窗口的url、新窗口的标识name(String)、新窗口的特性值feature(String，逗号分隔)，还返回该窗口对象的引用nenWindow，我们可以借此加一层判断，实现同时只可以有一个新窗口存在，如最上面的代码。</p><p>其中第三个参数可以自行选择设定。这里先普及一下浏览器页面上各元素的名称：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E.gif" alt="浏览器介绍"></p><p>参照上面的图，便可通过<code>window.open()</code>函数对新窗口的页面元素进行自定义。比如上面的<code>resizable=yes, scrollbars=yes</code>,还有<code>menubars,titlebars,location</code>等等。</p><p>这里支持4种风格的字符串配置风格：</p><blockquote><ol><li>menubar=yes,toolbar=yes,scrollbars=no</li><li>menubar=on,toolbar=on,scrollbars=off</li><li>menubar=1,toolbar=1,scrollbars=0</li><li>menubar,toolbar,scrollbars(写的有，不写的就没有)</li></ol></blockquote><p>更详细的参数说明请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open" target="_blank" rel="external">JavaScript开发手册</a></p><h3 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h3><ol><li>某些情况下，用户对浏览器的设置可能导致某些特性按用户的设定来，而非js里的设定；</li><li>某些安全软件可能禁止了浏览器弹出新窗口；</li><li>调用window.open()方法以后，远程 URL 不会被立即载入，载入过程是异步的。（实际加载这个URL的时间推迟到当前脚本块执行结束之后。窗口的创建和相关资源的加载异步地进行。）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="http://ssdna.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ajax用JQuery实现的一种个人常用写法</title>
    <link href="http://ssdna.github.io/2016/07/30/Ajax-in-JQuery-and-Primitive-JavaScript/"/>
    <id>http://ssdna.github.io/2016/07/30/Ajax-in-JQuery-and-Primitive-JavaScript/</id>
    <published>2016-07-30T13:23:21.000Z</published>
    <updated>2017-10-09T10:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。</p><a id="more"></a><p> 这种技术在浏览器上应用非常广泛，这里仅记录几种我个人用Ajax时常用的方便调试的写法。</p><h2 id="JQuery写法"><a href="#JQuery写法" class="headerlink" title="JQuery写法"></a>JQuery写法</h2><h3 id="个人自用写法"><a href="#个人自用写法" class="headerlink" title="个人自用写法"></a>个人自用写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    url: <span class="string">"http://nucNaOH.github.io/"</span>,</div><div class="line">    type: <span class="string">"POST"</span>,</div><div class="line">    timeout: <span class="number">5000</span>,</div><div class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,         <span class="comment">// default is true</span></div><div class="line">    data: &#123;</div><div class="line">        text: text</div><div class="line">    &#125;,</div><div class="line">    dataType: <span class="string">"json"</span>,       <span class="comment">// xml,json,jsonp,script,html,text.</span></div><div class="line">    <span class="comment">// 一般从数据库查找出来的结果，返回都是json格式。页面用html</span></div><div class="line">    beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('beforeSend:'+text);</span></div><div class="line">    &#125;,</div><div class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('success'+data);</span></div><div class="line">    &#125;,</div><div class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log(jqXHR);</span></div><div class="line">        <span class="comment">// 该函数的三个参数：</span></div><div class="line">        <span class="comment">// jqXHR jqXHR, String statusText, String errorThrown</span></div><div class="line">    &#125;,</div><div class="line">    complete : <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, statusText, settings</span>) </span>&#123;</div><div class="line">        <span class="comment">// 无论success、error都会执行，且在success、error之后</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="连贯写法："><a href="#连贯写法：" class="headerlink" title="连贯写法："></a>连贯写法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</div><div class="line">  .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $( <span class="keyword">this</span> ).addClass( <span class="string">"done"</span> );</div><div class="line">    <span class="comment">// alert( "success" );</span></div><div class="line">  &#125;)</div><div class="line">  .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"error"</span> );</div><div class="line">  &#125;)</div><div class="line">  .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"complete"</span> );</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h2 id="原生js写法"><a href="#原生js写法" class="headerlink" title="原生js写法"></a>原生js写法</h2><p>原生的JavaScript实现ajax技术的写法：</p><h3 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqListener</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">oReq.onload = reqListener;</div><div class="line">oReq.open(<span class="string">'get'</span>, <span class="string">'some.php'</span>, <span class="literal">true</span>);</div><div class="line">oReq.send();</div></pre></td></tr></table></figure><h3 id="多事件监听版"><a href="#多事件监听版" class="headerlink" title="多事件监听版"></a>多事件监听版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">req.addEventListener(<span class="string">"progress"</span>, updateProgress, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"load"</span>, transferComplete, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"error"</span>, transferFailed, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"abort"</span>, transferCanceled, <span class="literal">false</span>);</div><div class="line"></div><div class="line">req.open();</div><div class="line"></div><div class="line"><span class="comment">// 传输进度监听 (下载)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (evt.lengthComputable) &#123;</div><div class="line">    <span class="keyword">var</span> percentComplete = evt.loaded / evt.total;</div><div class="line"></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 总长度没设置时无法监听进度</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="external">Using XMLHttpRequest</a></li><li><a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="Ajax" scheme="http://ssdna.github.io/tags/Ajax/"/>
    
      <category term="JQuery" scheme="http://ssdna.github.io/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo在GitHub上搭建博客</title>
    <link href="http://ssdna.github.io/2016/07/14/Build-Hexo-Blog-by-Using-GitHub-Pages/"/>
    <id>http://ssdna.github.io/2016/07/14/Build-Hexo-Blog-by-Using-GitHub-Pages/</id>
    <published>2016-07-14T04:08:54.000Z</published>
    <updated>2018-04-21T11:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了使用hexo在GitHub上搭建博客，特此记录。</p><h2 id="需要安装的软件"><a href="#需要安装的软件" class="headerlink" title="需要安装的软件"></a>需要安装的软件</h2><ol><li><a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="external">Git</a><a id="more"></a></li></ol><h2 id="Git与GitHub相关"><a href="#Git与GitHub相关" class="headerlink" title="Git与GitHub相关"></a>Git与GitHub相关</h2><h4 id="注册并创建GitHub仓库"><a href="#注册并创建GitHub仓库" class="headerlink" title="注册并创建GitHub仓库"></a>注册并创建GitHub仓库</h4><p>仓库名字格式应为：<code>githubname.github.io</code>，类型为<code>Public</code>即可。创建成功后会生成该仓库的git地址，格式如下：</p><blockquote><p><a href="https://github.com/your_name/your_name.github.io.git" target="_blank" rel="external">https://github.com/your_name/your_name.github.io.git</a></p></blockquote><h4 id="Git本地配置"><a href="#Git本地配置" class="headerlink" title="Git本地配置"></a>Git本地配置</h4><p>在本地Git Bash中配置个人名字和邮箱，用来记录提交信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"your_name"</span></div><div class="line">$ git config --global user.email <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure></p><h4 id="SSH-key配置"><a href="#SSH-key配置" class="headerlink" title="SSH key配置"></a>SSH key配置</h4><p>SSH key是用来将本地Git与远程的GitHub关联起来的关键配置。在本地Git bash中执行如下命令：</p><h4 id="1-检查SSH-key的设置"><a href="#1-检查SSH-key的设置" class="headerlink" title="1. 检查SSH key的设置"></a>1. 检查SSH key的设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure><h4 id="2-备份并移除原来的SSH-key"><a href="#2-备份并移除原来的SSH-key" class="headerlink" title="2. 备份并移除原来的SSH key"></a>2. 备份并移除原来的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">$ mkdir key_backup</div><div class="line">$ cp id_rsa* key_backup</div><div class="line">$ rm id_rsa*</div></pre></td></tr></table></figure><h4 id="3-生成新的SSH-key"><a href="#3-生成新的SSH-key" class="headerlink" title="3. 生成新的SSH key"></a>3. 生成新的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure><h4 id="4-添加SSH-key到远程GitHub"><a href="#4-添加SSH-key到远程GitHub" class="headerlink" title="4. 添加SSH key到远程GitHub"></a>4. 添加SSH key到远程GitHub</h4><p>生成的<em>id_rsa</em>是私钥，需要保管好，而公钥<em>id_rsa.pub</em>中的内容需要在个人GitHub主页的Settings里的SSH and GPG keys选项中添加上，title项可根据个人习惯随便写。</p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure><h2 id="Hexo的安装与使用"><a href="#Hexo的安装与使用" class="headerlink" title="Hexo的安装与使用"></a>Hexo的安装与使用</h2><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Hexo是一个快速、简洁且高效的博客框架。在安装完node.js之后，就可以在命令行或git bash中使用npm命令进行安装Hexo了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p><h4 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h4><p>安装完hexo后，在需要的文件夹下（以F:/Hexo为例）右键-&gt;”Git Bash Here”，在git bash中输入如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init <span class="string">"your_blog"</span></div><div class="line">$ hexo g</div><div class="line">$ hexo s</div></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>便能在本地预览博客效果</p><h2 id="发布博客到GitHub-Repo"><a href="#发布博客到GitHub-Repo" class="headerlink" title="发布博客到GitHub Repo"></a>发布博客到GitHub Repo</h2><h4 id="本地仓库跟GitHub建立联系"><a href="#本地仓库跟GitHub建立联系" class="headerlink" title="本地仓库跟GitHub建立联系"></a>本地仓库跟GitHub建立联系</h4><p>在Hexo生成的.deploy_git文件夹下用git将其与远程仓库建立联系（只需要执行一次）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git remote -v</div><div class="line">$ git remote add origin git@github.com:your_name/your_name.github.io.git</div></pre></td></tr></table></figure></p><h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure><p>Hexo还有很多好用的模板可供使用，详细的使用方法此处仅贴几个相关链接，供后续学习使用。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo theme</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo github</a><br><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo 官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了使用hexo在GitHub上搭建博客，特此记录。&lt;/p&gt;
&lt;h2 id=&quot;需要安装的软件&quot;&gt;&lt;a href=&quot;#需要安装的软件&quot; class=&quot;headerlink&quot; title=&quot;需要安装的软件&quot;&gt;&lt;/a&gt;需要安装的软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git&lt;/a&gt;
    
    </summary>
    
      <category term="个人小研究" scheme="http://ssdna.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Hexo" scheme="http://ssdna.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://ssdna.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Apache多站点管理</title>
    <link href="http://ssdna.github.io/2016/07/13/Multisites-Setting-in-Apache/"/>
    <id>http://ssdna.github.io/2016/07/13/Multisites-Setting-in-Apache/</id>
    <published>2016-07-13T11:37:32.000Z</published>
    <updated>2017-10-09T10:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改文件-apache-conftpd-ctf"><a href="#修改文件-apache-conftpd-ctf" class="headerlink" title="修改文件:apache/conftpd.ctf"></a>修改文件:apache/conftpd.ctf</h3><h4 id="找到这两句取消注释"><a href="#找到这两句取消注释" class="headerlink" title="找到这两句取消注释"></a>找到这两句取消注释</h4><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#LoadModule vhost_alias_module modules/mod_vhost_alias.so</span></div><div class="line"><span class="comment">#Include conf/extratpd-vhosts.conf</span></div></pre></td></tr></table></figure><h3 id="在DocumentRoot下添加："><a href="#在DocumentRoot下添加：" class="headerlink" title="在DocumentRoot下添加："></a>在DocumentRoot下添加：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Directory</span> "<span class="attr">F:</span>/<span class="attr">php</span>"&gt;</span></div><div class="line">    Options Indexes FollowSymLinks Includes ExecCGI   </div><div class="line">    AllowOverride All   </div><div class="line">    Require all granted</div><div class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改文件：apache-conf-extratpd-vhosts-conf"><a href="#修改文件：apache-conf-extratpd-vhosts-conf" class="headerlink" title="修改文件：apache/conf/extratpd-vhosts.conf"></a>修改文件：apache/conf/extratpd-vhosts.conf</h3><h4 id="添加以下内容"><a href="#添加以下内容" class="headerlink" title="添加以下内容"></a>添加以下内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></div><div class="line">    DocumentRoot "F:/php"   </div><div class="line">ServerName www.zhangziye.com</div><div class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改C-windows-system32-drivers-detc-hosts"><a href="#修改C-windows-system32-drivers-detc-hosts" class="headerlink" title="修改C:/windows/system32/drivers/detc/hosts"></a>修改C:/windows/system32/drivers/detc/hosts</h3><h4 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h4><blockquote><p>127.0.0.1       www.zhangziye.com##注意前面不要加#号</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改文件-apache-conftpd-ctf&quot;&gt;&lt;a href=&quot;#修改文件-apache-conftpd-ctf&quot; class=&quot;headerlink&quot; title=&quot;修改文件:apache/conftpd.ctf&quot;&gt;&lt;/a&gt;修改文件:apache/conftpd.ctf&lt;/h3&gt;&lt;h4 id=&quot;找到这两句取消注释&quot;&gt;&lt;a href=&quot;#找到这两句取消注释&quot; class=&quot;headerlink&quot; title=&quot;找到这两句取消注释&quot;&gt;&lt;/a&gt;找到这两句取消注释&lt;/h4&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://ssdna.github.io/categories/Apache/"/>
    
    
      <category term="Apache" scheme="http://ssdna.github.io/tags/Apache/"/>
    
  </entry>
  
</feed>
