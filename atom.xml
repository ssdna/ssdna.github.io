<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DNA&#39; Blog</title>
  
  <subtitle>个人学习记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ssdna.github.io/"/>
  <updated>2017-10-27T06:33:32.000Z</updated>
  <id>http://ssdna.github.io/</id>
  
  <author>
    <name>DNA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Server-sent Events学习记录</title>
    <link href="http://ssdna.github.io/2017/10/26/A-note-of-Server-sent-Events/"/>
    <id>http://ssdna.github.io/2017/10/26/A-note-of-Server-sent-Events/</id>
    <published>2017-10-26T11:29:20.000Z</published>
    <updated>2017-10-27T06:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>服务器推送事件（Server-sent Events，简称<code>SSE</code>，下同）是<a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model" target="_blank" rel="external">HTML5规范</a>中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于WebSocket技术来说，SSE只是单向通信（只能实现服务器向浏览器推送消息，而浏览器不能通过sse向服务器主动发送消息），使用起来也更加简单，对服务器端的改动也比较小，特别适合于诸如监控数据、消息推送等应用场景。</p><a id="more"></a><h2 id="SSE简述"><a href="#SSE简述" class="headerlink" title="SSE简述"></a>SSE简述</h2><p>Server-sent Events比较简单，主要由<strong>两个部分</strong>组成：</p><ol><li>第一个部分是服务器端与浏览器端之间的<code>通讯协议</code>（基于纯文本）；</li><li>第二部分则是在浏览器端可供 JavaScript 使用的 <code>EventSource</code> 对象。</li></ol><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>这里详细介绍SSE的通信协议。</p><ul><li>SSE的通讯协议是基于<code>纯文本</code>的简单协议，即服务端和浏览器之间采用纯文本进行通信。</li><li>服务器端响应的头部信息（内容类型）<code>Content-Type</code>必须是<code>text/event-stream</code>。</li><li>响应文本的内容可以看成是一个事件流（<code>Event stream</code>），由不同的事件所组成。</li><li>事件流（<code>Event stream</code>）强制使用UTF8编码，且无法修改编码方式;</li><li>每个事件由<code>类型(event)</code>和<code>数据(data)</code>两部分组成，同时每个事件可以有一个可选的<code>标识符(id)</code>。</li><li>事件流中每行的结尾可以是<code>CRLF</code>、<code>LF</code>、<code>CR</code>三者中的任意一个。（<code>CRLF</code>是Carriage-Return Line-Feed的缩写，意思是回车换行，就是回车(<code>CR</code>, ASCII 13, <code>\r</code>) 与换行(<code>LF</code>, ASCII 10, <code>\n</code>)）</li><li>每个事件的数据可能由多行组成，每个事件之间通过额外的空行（<code>CRLF</code>、<code>LF</code>、<code>CR</code>三者中的任意一个）来分隔。</li><li>对于每一行来说，冒号（<code>:</code>）前面表示的是该行的类型，冒号后面则是对应的值（可以为空）。其事件类型如下：</li></ul><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><p>SSE的事件类型可分为五类。</p><ol><li><p>类型为 空白，表示该行是注释，会在处理时被忽略。举例如下：</p><ul><li>空白注释<blockquote><p>:</p></blockquote></li><li>带描述的注释<blockquote><p>:this is a commont</p></blockquote></li></ul></li><li><p>类型为 data，表示该行包含的是数据。以data开头的行可以连续出现多次，所有这些行都是该事件的数据。多行data最终的数据每行与每行中间都有一个<code>\n</code>，但最后没有<code>\n</code>。举例如下：</p><ul><li>单行data，最终data为：”sse event”<blockquote><p>data:sse event</p></blockquote></li><li>多行data，最终data为：”AAAA\nBBBB”<blockquote><p>data: AAAA<br>data:BBBB</p></blockquote></li></ul></li><li><p>类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。举例如下：</p><ul><li>自定义myevnet，可触发<code>source.addEventListener(&#39;myevent&#39;, (event) =&gt; {console.log(event.data)})</code>。其中，<code>event.data===&#39;my event data\ncontinue&#39;</code><blockquote><p>event: myevent<br>data: my event data<br>data:continue</p></blockquote></li></ul></li><li><p>类型为 id，表示该行用来声明事件的标识符（整数字符串）。标识符id主要用在尝试重连的请求头<code>Last-Event-ID</code>字段中，给服务器提供信息。举例如下：</p><ul><li>指定标识符id，如果此时断开连接，下次重连时的请求头中会自动将’30’放在<code>Last-Event-ID</code>字段中，服务器可以根据这个请求头字段做特定的处理。<blockquote><p>id: 30<br>data: dddd</p></blockquote></li></ul></li><li><p>类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间（毫秒数），服务器可以动态调节推送频率。</p><ul><li>指定下次重连时间为3000ms，可动态变化<blockquote><p>retry: 3000</p></blockquote></li></ul></li></ol><h4 id="事件数据"><a href="#事件数据" class="headerlink" title="事件数据"></a>事件数据</h4><p>服务器端响应内容的示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data: first event</div><div class="line"></div><div class="line">data: second event</div><div class="line">id: 100</div><div class="line"></div><div class="line">event: myevent</div><div class="line">data: third event</div><div class="line">retry: 3000</div><div class="line">id: 101</div><div class="line"></div><div class="line">: this is a comment，注意最后一行的多余空行</div><div class="line">data: fourth event</div><div class="line">data: fourth event continue</div></pre></td></tr></table></figure><h4 id="相关HTTP-header"><a href="#相关HTTP-header" class="headerlink" title="相关HTTP header"></a>相关HTTP header</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 响应头</div><div class="line">Content-Type:text/event-stream;</div><div class="line">Cache-Control:no-cache</div><div class="line">// 请求头（只有在SSE重连时，浏览器端才会找到上一个合法的id，并通过以下请求头字段发送给服务器）</div><div class="line">Last-Event-ID:2</div></pre></td></tr></table></figure><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul><li>Event stream请求可以通过HTTP状态码301和307进行重定向；</li><li>当连接关闭时，浏览器会尝试自动重连，除非收到HTTP状态吗204（No Content）；</li><li>Event stream中，冒号（<code>:</code>）可以在行首表示改行是注释；</li><li>Event stream中，非注释行冒号（<code>:</code>）后可以有一个空格，该空格不会计入data buffer中；</li><li>Event stream中，最后一行如果没有额外的空行，会导致最后一个事件推送不成功；</li><li>对于代理服务器，因其在特定情况下会在短暂的延时后断开HTTP连接，设计者可以考虑每隔15s推送一条注释消息；</li><li>在SSE重连时，浏览器端会找到上一个合法的id，跳过那些没有设置id的事件，并通过Last-Event-ID请求头字段发送给服务器；如果上一条id为空，则表示清空last event ID string，这种情况下，浏览器重连时并不会发送Last-Event-ID请求头字段。</li></ul><h3 id="Event-Source对象"><a href="#Event-Source对象" class="headerlink" title="Event Source对象"></a>Event Source对象</h3><p>Event Source对象有4个要点，其中后3个都不暴露在Event Source对象上：</p><ol><li>url；</li><li>请求；</li><li>重连事件；</li><li>last event ID string；</li></ol><p>Event Source对象有如下API接口：</p><ul><li>url (read-only);</li><li>withCredentials (read-only);</li><li>readyState // CONNECTING (0), OPEN (1), CLOSED (2)</li><li>EventHandler // onopen, onmessage, onerror</li><li>close (voic)</li></ul><h2 id="具体实现方案"><a href="#具体实现方案" class="headerlink" title="具体实现方案"></a>具体实现方案</h2><h3 id="Browser端"><a href="#Browser端" class="headerlink" title="Browser端"></a>Browser端</h3><p>目前，除IE外，几乎所有的浏览器都支持sse，即window下有EventSource属性（对象）。对于IE可以使用简易轮询或<code>COMET</code>技术来实现，也可以使用<a href="https://github.com/Yaffle/EventSource" target="_blank" rel="external">polyfill</a>。</p><p>下图是我在<a href="http://caniuse.com/#search=EventSource" target="_blank" rel="external">Can I use</a>上针对SSE于2017年10月26日的查询结果:<br><img src="Can-I-use-sse.png" alt="Can I use sse"></p><ul><li>具体实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// constructor. When invoked, must init env &amp; fetch request</span></div><div class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost/sse.php'</span>);</div><div class="line"><span class="comment">// onmessage. Also: 'onopen', 'onerror'</span></div><div class="line">source.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// custom event listener. Also: 'open', 'message', 'error'</span></div><div class="line">source.addEventListener(<span class="string">'event1'</span>, event =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><h4 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h4><h5 id="1-简单版"><a href="#1-简单版" class="headerlink" title="1. 简单版"></a>1. 简单版</h5><p>鄙人常用的后台语言是PHP，网上对PHP实现SSE的大部分实现方法<a href="http://www.w3school.com.cn/html5/html_5_serversentevents.asp" target="_blank" rel="external">如下</a>（来自w3cshool）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 简单版</span></div><div class="line"><span class="comment"> * http://www.w3school.com.cn/html5/html_5_serversentevents.asp</span></div><div class="line"><span class="comment"> */</span></div><div class="line">header(<span class="string">'Content-Type: text/event-stream'</span>);</div><div class="line">header(<span class="string">'Cache-Control: no-cache'</span>);</div><div class="line"></div><div class="line">date_default_timezone_set(<span class="string">'UTC'</span>);</div><div class="line">$time = date(<span class="string">'r'</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">"event: event1\n"</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>;</div><div class="line">flush();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>经测试，上述简单版的PHP代码虽然能实现推送的功能，但这种写法实际上的效果其实跟轮询差不多。之所以这么讲，是因为从chrome开发调试工具的Network里可以看到间歇性的多条类型为eventsource的请求，如下图示。</p><img src="/images/sse/network-console.png" width="500" height="450" title="Network Console"><img src="/images/sse/network-eventstream.png" width="500" height="450" title="Network Eventstream"><p>这是因为浏览器上的EventSource实例默认会自动重连。上述PHP代码实际上只是一个HTTP短连接，只提供一次简短的sse推送。正是由于自动重连的存在，所以每次短暂的sse推送之后，每隔一段时间便会有一次重连再获取一次新的简短的sse推送。</p><h5 id="2-while-true-版"><a href="#2-while-true-版" class="headerlink" title="2. while(true)版"></a>2. while(true)版</h5><p>另一种实现方法是<code>while(true)</code>的写法，虽然又会造成服务器端资源的浪费（例如HTTP长连接等）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * while(true)版</span></div><div class="line"><span class="comment"> */</span></div><div class="line">header(<span class="string">'Content-Type: text/event-stream'</span>); </div><div class="line">header(<span class="string">'Cache-Control: no-cache'</span>); </div><div class="line"></div><div class="line">date_default_timezone_set(<span class="string">'UTC'</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    $time = date(<span class="string">'r'</span>); </div><div class="line">    <span class="keyword">echo</span> <span class="string">"data: The server time is: &#123;$time&#125;\n\n"</span>; </div><div class="line">    ob_flush();</div><div class="line">    flush(); </div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><img src="/images/sse/network-console-while-true.png" width="500" height="450" title="Network Eventstream"><h5 id="3-终极版"><a href="#3-终极版" class="headerlink" title="3. 终极版"></a>3. 终极版</h5><p>改进的方法是定时或定次（推送事件的次数）服务器端主动断开HTTP长连接，并根据每次推送事件的id（last-evnet-id）来在再次重连的时候恢复推送记录。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 改进版，会定时断开长连接，并能根据last event id恢复</span></div><div class="line"><span class="comment"> * https://github.com/Yaffle/EventSource</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">  header(<span class="string">"Content-Type: text/event-stream"</span>);</div><div class="line">  header(<span class="string">"Cache-Control: no-store"</span>);</div><div class="line">  header(<span class="string">"Access-Control-Allow-Origin: *"</span>);</div><div class="line"></div><div class="line">  $lastEventId = floatval(<span class="keyword">isset</span>($_SERVER[<span class="string">"HTTP_LAST_EVENT_ID"</span>]) ? $_SERVER[<span class="string">"HTTP_LAST_EVENT_ID"</span>] : <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> ($lastEventId == <span class="number">0</span>) &#123;</div><div class="line">    $lastEventId = floatval(<span class="keyword">isset</span>($_GET[<span class="string">"lastEventId"</span>]) ? $_GET[<span class="string">"lastEventId"</span>] : <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">echo</span> <span class="string">"retry: 2000\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// event-stream</span></div><div class="line">  $i = $lastEventId;</div><div class="line">  $c = $i + <span class="number">100</span>;</div><div class="line">  <span class="keyword">while</span> (++$i &lt; $c) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"id: "</span> . $i . <span class="string">"\n"</span>;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"data: "</span> . $i . <span class="string">";\n\n"</span>;</div><div class="line">    ob_flush();</div><div class="line">    flush();</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h4 id="nodejs实现"><a href="#nodejs实现" class="headerlink" title="nodejs实现"></a>nodejs实现</h4><p>这里使用node自带的http库来实现，简单添加了允许所有域跨域请求的请求头，随机推送一个事件，并且会定次（100次）断开长连接，并能根据last event id恢复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="comment">// options</span></div><div class="line"><span class="keyword">const</span> options = &#123;</div><div class="line">    port: <span class="number">3003</span>,</div><div class="line">    intervalTime: <span class="number">3000</span>,</div><div class="line">    interval: <span class="literal">null</span>,</div><div class="line">    events: [<span class="string">'connected'</span>, <span class="string">'event1'</span>, <span class="string">'event2'</span>, <span class="string">'event3'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 会定次断开长连接，并能根据last event id恢复</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// headers of SSE(Server-sent Events) &amp; CORS(Cross Origin Resources Sharing)</span></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span>,</div><div class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</div><div class="line">        <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// SSE stream</span></div><div class="line">    response.write(<span class="string">`retry: <span class="subst">$&#123;options.interValTime&#125;</span>\n`</span>);</div><div class="line">    response.write(<span class="string">`event: <span class="subst">$&#123;options.events[<span class="number">0</span>]&#125;</span>\n`</span>);</div><div class="line">    response.write(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()&#125;</span>\n\n`</span>);</div><div class="line">    <span class="comment">// last event id</span></div><div class="line">    <span class="keyword">let</span> lastEventId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (request.headers[<span class="string">"last-event-id"</span>] !== <span class="literal">undefined</span>) &#123;</div><div class="line">        lastEventId = <span class="built_in">Number</span>(request.headers[<span class="string">"last-event-id"</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> i = lastEventId;</div><div class="line">    <span class="keyword">let</span> c = i + <span class="number">100</span>;</div><div class="line">    <span class="comment">// timeout function</span></div><div class="line">    <span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (++i &lt; c) &#123;</div><div class="line">        <span class="comment">// send events randomly</span></div><div class="line">        <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>) + <span class="number">1</span>;</div><div class="line">        response.write(<span class="string">`id: <span class="subst">$&#123;i&#125;</span>\n`</span>);</div><div class="line">        response.write(<span class="string">`event: <span class="subst">$&#123;options.events[index]&#125;</span>\n`</span>);</div><div class="line">        response.write(<span class="string">`data: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()&#125;</span>\n\n`</span>);</div><div class="line">        timeoutId = setTimeout(fun, <span class="number">1000</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        response.end();</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    fun();</div><div class="line"></div><div class="line">    <span class="comment">// close</span></div><div class="line">    request.connection.addListener(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'sse server closing...[browser side close]'</span>);</div><div class="line">        clearInterval(options.interval);</div><div class="line">        response.end();</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">&#125;)</div><div class="line">server.listen(options.port);</div></pre></td></tr></table></figure><p>以上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model" target="_blank" rel="external">HTML Specification</a>（强烈建议仔细研读）</li><li><a href="https://github.com/Yaffle/EventSource" target="_blank" rel="external">EventSource polyfill</a>（支持IE的polyfill）</li><li><a href="https://www.ibm.com/developerworks/cn/web/1307_chengfu_serversentevent/" target="_blank" rel="external">HTML5 服务器推送事件（Server-sent Events）实战开发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器推送事件（Server-sent Events，简称&lt;code&gt;SSE&lt;/code&gt;，下同）是&lt;a href=&quot;https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTML5规范&lt;/a&gt;中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于WebSocket技术来说，SSE只是单向通信（只能实现服务器向浏览器推送消息，而浏览器不能通过sse向服务器主动发送消息），使用起来也更加简单，对服务器端的改动也比较小，特别适合于诸如监控数据、消息推送等应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://ssdna.github.io/categories/HTML5/"/>
    
    
      <category term="SSE" scheme="http://ssdna.github.io/tags/SSE/"/>
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="PHP" scheme="http://ssdna.github.io/tags/PHP/"/>
    
      <category term="nodejs" scheme="http://ssdna.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API设计总结</title>
    <link href="http://ssdna.github.io/2017/09/29/A-Note-of-RESTful-API-Design/"/>
    <id>http://ssdna.github.io/2017/09/29/A-Note-of-RESTful-API-Design/</id>
    <published>2017-09-29T02:37:32.000Z</published>
    <updated>2017-10-09T10:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是<code>ThinkPHP5</code>，前端部分用的是<code>vue2+vue-router+vuex</code>的全家桶，用<code>axios</code>进行数据交互。这里总结一下对RESTful API的学习和设计心得。</p><a id="more"></a><h3 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h3><p>RESTful（Representational State Transfer，表现层状态转移）是一种软件架构风格，主要用于客户端（包括浏览器）与服务器端进行数据交互的场景。一个好的RESTful API设计，可以让服务器端只实现一套API接口，就能同时为Web应用、移动端、电脑端同时提供更简洁，更有层次，更易于实现缓存的服务。</p><h3 id="RESTful设计举例"><a href="#RESTful设计举例" class="headerlink" title="RESTful设计举例"></a>RESTful设计举例</h3><p><a href="">知乎</a>上对RESTful API有一条言简意赅的解释：</p><blockquote><p>看<code>url</code>就知道要什么，看<code>http method</code>就知道干什么，看<code>http status code</code>就知道结果如何。</p></blockquote><p>举个例子：如果拿课程(course)作为一个资源，对其进行符合RESTful的API接口设计，其url一般可以设计成如下格式：</p><ul><li>获取课程资源列表<br>[GET] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程资源<br>[GET] <code>http://api.hostname.com/v1/courses/id</code></li><li>新建课程资源<br>[POST] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（全部）<br>[PUT] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（部分）<br>[PATCH] <code>http://api.hostname.com/v1/courses</code></li><li>删除课程资源<br>[DELETE] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程下的实验资源列表<br>[GET] <code>http://api.hostname.com/v1/courses/id/experiments</code></li><li>获取课程资源列表（分页查询）<br>[GET] <code>http://api.hostname.com/v1/courses?query=&amp;page=2&amp;per_page=100</code></li></ul><p>由上述例子可以看出，RESTful用<code>url</code>来表示一个资源（列表），用<code>HTTP method</code>来表示对资源的增删改查，用<code>http请求参数</code>来对访问的资源作进一步限定。一些实际应用中公认的设计优良的的RESTful API可以参考<a href="">github</a>和<a href="">leancloud</a>。</p><h3 id="RESTful设计准则"><a href="#RESTful设计准则" class="headerlink" title="RESTful设计准则"></a>RESTful设计准则</h3><p>按上述几个方面划分，RESTful设计需要符合如下准则：</p><h4 id="一、url"><a href="#一、url" class="headerlink" title="一、url"></a>一、url</h4><p>RESTful架构中的url代表的是一个资源。url一般需要符合如下要求：</p><ol><li>url中最好加入API的<strong>版本号</strong>信息；</li><li>url中尽量用<strong>名词</strong>表示资源；</li><li>url中尽量用名词的<strong>复数</strong>；</li><li>url中一般会加入可选的<strong>参数</strong>（如<code>id</code>），表示对资源限制条件；</li><li>url中可按需加入过滤信息（如<code>?q=&amp;page=2&amp;per_page=100</code>、<code>?sortby=name&amp;order=asc</code>、<code>?type=1</code>等）；</li></ol><h4 id="二、http-method"><a href="#二、http-method" class="headerlink" title="二、http method"></a>二、http method</h4><p>RESTful中用到的http method如下：</p><ul><li>// 常用</li><li>GET     (SELECT)    ：获出资源（一项或多项）。</li><li>POST    (CREATE)    ：新建一个资源。</li><li>PUT     (UPDATE)    ：更新资源（客户端提供改变后的完整资源）。</li><li>PATCH   (UPDATE)    ：更新资源（客户端只提供待改变部分的属性）。</li><li>DELETE  (DELETE)    ：删除资源。</li><li>// 不常用</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h4 id="三、http-status-code"><a href="#三、http-status-code" class="headerlink" title="三、http status code"></a>三、http status code</h4><p>RESTful API返回的响应结果中，其<strong>http状态码</strong>应该按照http规范对响应结果的状态进行表示。常见的状态码与提示信息如下：</p><ul><li>200 OK                      – [GET] 操作成功</li><li>201 CREATED                 – [POST/PUT/PATCH] 新建/修改数据成功</li><li>204 NO CONTENT              – [DELETE] 删除数据成功</li><li>400 INVALID REQUEST         – [POST/PUT/PATCH] 请求的数据有误</li><li>404 NOT FOUND               – [*] 资源不存在</li><li>500 INTERNAL SERVER ERROR   – [*] 服务器发生错误</li></ul><h4 id="四、other"><a href="#四、other" class="headerlink" title="四、other"></a>四、other</h4><ol><li>对于4xx的错误情况，需要将错误的信息返回，比如<code>{&quot;error&quot;:&quot;没有权限！&quot;}</code>；</li><li>返回的结果尽量使用<strong>json</strong>格式；</li><li>最好添加身份验证，如<code>OAuth 2.0</code>，或<code>api_key</code>;</li><li>最好做到<strong>Hypermedia</strong>，即在返回结果中提供指向该API的说明文档链接或其他相关API的链接。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是&lt;code&gt;ThinkPHP5&lt;/code&gt;，前端部分用的是&lt;code&gt;vue2+vue-router+vuex&lt;/code&gt;的全家桶，用&lt;code&gt;axios&lt;/code&gt;进行数据交互。这里总结一下对RESTful API的学习和设计心得。&lt;/p&gt;
    
    </summary>
    
      <category term="RESTful" scheme="http://ssdna.github.io/categories/RESTful/"/>
    
    
      <category term="RESTful" scheme="http://ssdna.github.io/tags/RESTful/"/>
    
      <category term="API" scheme="http://ssdna.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享技术总结</title>
    <link href="http://ssdna.github.io/2017/09/28/A-Note-of-CORS/"/>
    <id>http://ssdna.github.io/2017/09/28/A-Note-of-CORS/</id>
    <published>2017-09-28T13:25:21.000Z</published>
    <updated>2017-10-26T10:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨域资源共享，即Cross-origin Resource Sharing（下称<code>CORS</code>），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。</p><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><p>浏览器的同源策略</p><h3 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h3><p>An origin is defined by the scheme, host, and port of a URL.</p><p>### </p><p>## </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域资源共享，即Cross-origin Resource Sharing（下称&lt;code&gt;CORS&lt;/code&gt;），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的同源策略&quot;&gt;&lt;a href=&quot;#浏览器的同源策略&quot; class=&quot;headerlink&quot; title=&quot;浏览器的同源策略&quot;&gt;&lt;/a&gt;浏览器的同源策略&lt;/h2&gt;&lt;p&gt;浏览器的同源策略&lt;/p&gt;
&lt;h3 id=&quot;源的定义&quot;&gt;&lt;a href=&quot;#源的定义&quot; class=&quot;headerlink&quot; title=&quot;源的定义&quot;&gt;&lt;/a&gt;源的定义&lt;/h3&gt;&lt;p&gt;An origin is defined by the scheme, host, and port of a URL.&lt;/p&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://ssdna.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="Browser" scheme="http://ssdna.github.io/tags/Browser/"/>
    
      <category term="ThinkPHP" scheme="http://ssdna.github.io/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>js小技巧之----获取窗口resize完成之后的事件</title>
    <link href="http://ssdna.github.io/2016/07/31/Simulate-onresized-Event-by-Using-settimeout/"/>
    <id>http://ssdna.github.io/2016/07/31/Simulate-onresized-Event-by-Using-settimeout/</id>
    <published>2016-07-30T16:46:31.000Z</published>
    <updated>2017-10-09T10:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>用js可以方便地获取浏览器窗口<code>onResize</code>事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(<code>onResizeCompleted</code>)却比较麻烦。</p><a id="more"></a><h2 id="获取onResize事件"><a href="#获取onResize事件" class="headerlink" title="获取onResize事件"></a>获取<code>onResize</code>事件</h2><h3 id="js原生代码"><a href="#js原生代码" class="headerlink" title="js原生代码"></a>js原生代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth + <span class="string">' '</span> + <span class="built_in">window</span>.innerHeight);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="JQuery代码"><a href="#JQuery代码" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log($(<span class="built_in">window</span>).width() + <span class="string">' '</span> + $(<span class="built_in">window</span>).height());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>上面的代码，可以使浏览器在resize的时候在控制台console实时输出当前页面的长、宽像素。这里就不贴图了，可以看到随着鼠标对浏览器窗口的拖动(onResize)时，console里有很多的数据在实时输出。也就是说，上面的函数在resize的时候执行了很多次！</p><p>那么问题来了：如果我想只想监听浏览器窗口resize结束的事件该怎么做呢？也就是说，如果我只想让一个函数在浏览器窗口resize结束之后只执行一次，而不是一直执行，该怎么做呢？</p><h2 id="获取onResizeCompleted事件"><a href="#获取onResizeCompleted事件" class="headerlink" title="获取onResizeCompleted事件"></a>获取<code>onResizeCompleted</code>事件</h2><h3 id="js原生代码-1"><a href="#js原生代码-1" class="headerlink" title="js原生代码"></a>js原生代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">clearTimeout(resizeTimer);</div><div class="line">resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// 此函数会在resize结束的时候执行</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">&#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="JQuery代码-1"><a href="#JQuery代码-1" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  clearTimeout(resizeTimer);</div><div class="line">  resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 此函数在resize结束的时候执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">  &#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里利用setTimeout()函数配合对应的clearTimeout()函数不断被执行，实现了简单的计时器Timer，当resize事件触发后停下来的250ms时间后，执行内部的匿名函数，模拟实现对<code>onResizeCompleted</code>事件的监听。当然，这里的250ms可以根据实际的需求进行自己的设定，不过已经符合大部分的情况了，我在noVNC里也见到过同样的设定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种小技巧，可能会在处理别的类似的事件的时候会有用，有待验证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用js可以方便地获取浏览器窗口&lt;code&gt;onResize&lt;/code&gt;事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(&lt;code&gt;onResizeCompleted&lt;/code&gt;)却比较麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="Event" scheme="http://ssdna.github.io/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>用js弹出浏览器自定义精简窗口</title>
    <link href="http://ssdna.github.io/2016/07/30/Open-and-Control-a-customized-Window-in-Browser/"/>
    <id>http://ssdna.github.io/2016/07/30/Open-and-Control-a-customized-Window-in-Browser/</id>
    <published>2016-07-30T15:28:30.000Z</published>
    <updated>2017-10-09T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。<br><a id="more"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以调用如下的函数控制浏览器弹出自定义精简窗口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义新窗口相关的变量</span></div><div class="line"><span class="keyword">var</span> newWindow = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> newWindowName = <span class="string">"new_window"</span>;</div><div class="line"><span class="keyword">var</span> newWindowFeature = <span class="string">"resizable=yes, scrollbars=yes, left=200, top=100, width=600, height=400"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">popUpSimpleWindow</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 判断该窗口是否已经打开</span></div><div class="line"><span class="keyword">if</span>(newWindow == <span class="literal">null</span> || newWindow.closed) &#123;</div><div class="line"><span class="comment">// 打开上述自定义特性的窗口</span></div><div class="line">newWindow = <span class="built_in">window</span>.open(<span class="string">"http://nucNaOH.github.io"</span>, newWindowName, newWindowFeature);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">newWindow.focus();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">popUpSimpleWindow();</div></pre></td></tr></table></figure></p><p>效果如下图：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E7%B2%BE%E7%AE%80%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3.png" alt="精简窗口"></p><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><p>关键的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newWindow = <span class="built_in">window</span>.open(url, newWindowName, newWindowFeature);</div></pre></td></tr></table></figure></p><p>该函数的有三个参数，分别为新窗口的url、新窗口的标识name(String)、新窗口的特性值feature(String，逗号分隔)，还返回该窗口对象的引用nenWindow，我们可以借此加一层判断，实现同时只可以有一个新窗口存在，如最上面的代码。</p><p>其中第三个参数可以自行选择设定。这里先普及一下浏览器页面上各元素的名称：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E.gif" alt="浏览器介绍"></p><p>参照上面的图，便可通过<code>window.open()</code>函数对新窗口的页面元素进行自定义。比如上面的<code>resizable=yes, scrollbars=yes</code>,还有<code>menubars,titlebars,location</code>等等。</p><p>这里支持4种风格的字符串配置风格：</p><blockquote><ol><li>menubar=yes,toolbar=yes,scrollbars=no</li><li>menubar=on,toolbar=on,scrollbars=off</li><li>menubar=1,toolbar=1,scrollbars=0</li><li>menubar,toolbar,scrollbars(写的有，不写的就没有)</li></ol></blockquote><p>更详细的参数说明请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open" target="_blank" rel="external">JavaScript开发手册</a></p><h3 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h3><ol><li>某些情况下，用户对浏览器的设置可能导致某些特性按用户的设定来，而非js里的设定；</li><li>某些安全软件可能禁止了浏览器弹出新窗口；</li><li>调用window.open()方法以后，远程 URL 不会被立即载入，载入过程是异步的。（实际加载这个URL的时间推迟到当前脚本块执行结束之后。窗口的创建和相关资源的加载异步地进行。）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="http://ssdna.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ajax用JQuery实现的一种个人常用写法</title>
    <link href="http://ssdna.github.io/2016/07/30/Ajax-in-JQuery-and-Primitive-JavaScript/"/>
    <id>http://ssdna.github.io/2016/07/30/Ajax-in-JQuery-and-Primitive-JavaScript/</id>
    <published>2016-07-30T13:23:21.000Z</published>
    <updated>2017-10-09T10:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。</p><a id="more"></a><p> 这种技术在浏览器上应用非常广泛，这里仅记录几种我个人用Ajax时常用的方便调试的写法。</p><h2 id="JQuery写法"><a href="#JQuery写法" class="headerlink" title="JQuery写法"></a>JQuery写法</h2><h3 id="个人自用写法"><a href="#个人自用写法" class="headerlink" title="个人自用写法"></a>个人自用写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    url: <span class="string">"http://nucNaOH.github.io/"</span>,</div><div class="line">    type: <span class="string">"POST"</span>,</div><div class="line">    timeout: <span class="number">5000</span>,</div><div class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,         <span class="comment">// default is true</span></div><div class="line">    data: &#123;</div><div class="line">        text: text</div><div class="line">    &#125;,</div><div class="line">    dataType: <span class="string">"json"</span>,       <span class="comment">// xml,json,jsonp,script,html,text.</span></div><div class="line">    <span class="comment">// 一般从数据库查找出来的结果，返回都是json格式。页面用html</span></div><div class="line">    beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('beforeSend:'+text);</span></div><div class="line">    &#125;,</div><div class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('success'+data);</span></div><div class="line">    &#125;,</div><div class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log(jqXHR);</span></div><div class="line">        <span class="comment">// 该函数的三个参数：</span></div><div class="line">        <span class="comment">// jqXHR jqXHR, String statusText, String errorThrown</span></div><div class="line">    &#125;,</div><div class="line">    complete : <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, statusText, settings</span>) </span>&#123;</div><div class="line">        <span class="comment">// 无论success、error都会执行，且在success、error之后</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="连贯写法："><a href="#连贯写法：" class="headerlink" title="连贯写法："></a>连贯写法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</div><div class="line">  .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $( <span class="keyword">this</span> ).addClass( <span class="string">"done"</span> );</div><div class="line">    <span class="comment">// alert( "success" );</span></div><div class="line">  &#125;)</div><div class="line">  .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"error"</span> );</div><div class="line">  &#125;)</div><div class="line">  .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"complete"</span> );</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h2 id="原生js写法"><a href="#原生js写法" class="headerlink" title="原生js写法"></a>原生js写法</h2><p>原生的JavaScript实现ajax技术的写法：</p><h3 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqListener</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">oReq.onload = reqListener;</div><div class="line">oReq.open(<span class="string">'get'</span>, <span class="string">'some.php'</span>, <span class="literal">true</span>);</div><div class="line">oReq.send();</div></pre></td></tr></table></figure><h3 id="多事件监听版"><a href="#多事件监听版" class="headerlink" title="多事件监听版"></a>多事件监听版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">req.addEventListener(<span class="string">"progress"</span>, updateProgress, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"load"</span>, transferComplete, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"error"</span>, transferFailed, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"abort"</span>, transferCanceled, <span class="literal">false</span>);</div><div class="line"></div><div class="line">req.open();</div><div class="line"></div><div class="line"><span class="comment">// 传输进度监听 (下载)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (evt.lengthComputable) &#123;</div><div class="line">    <span class="keyword">var</span> percentComplete = evt.loaded / evt.total;</div><div class="line"></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 总长度没设置时无法监听进度</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="external">Using XMLHttpRequest</a></li><li><a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="Ajax" scheme="http://ssdna.github.io/tags/Ajax/"/>
    
      <category term="JQuery" scheme="http://ssdna.github.io/tags/JQuery/"/>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo在GitHub上搭建博客</title>
    <link href="http://ssdna.github.io/2016/07/14/Build-Hexo-Blog-by-Using-GitHub-Pages/"/>
    <id>http://ssdna.github.io/2016/07/14/Build-Hexo-Blog-by-Using-GitHub-Pages/</id>
    <published>2016-07-14T04:08:54.000Z</published>
    <updated>2017-10-09T10:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了使用hexo在GitHub上搭建博客，特此记录。</p><h2 id="需要安装的软件"><a href="#需要安装的软件" class="headerlink" title="需要安装的软件"></a>需要安装的软件</h2><ol><li><a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="external">Git</a><a id="more"></a></li></ol><h2 id="Git与GitHub相关"><a href="#Git与GitHub相关" class="headerlink" title="Git与GitHub相关"></a>Git与GitHub相关</h2><h4 id="注册并创建GitHub仓库"><a href="#注册并创建GitHub仓库" class="headerlink" title="注册并创建GitHub仓库"></a>注册并创建GitHub仓库</h4><p>仓库名字格式应为：<code>githubname.github.io</code>，类型为<code>Public</code>即可。创建成功后会生成该仓库的git地址，格式如下：</p><blockquote><p><a href="https://github.com/your_name/your_name.github.io.git" target="_blank" rel="external">https://github.com/your_name/your_name.github.io.git</a></p></blockquote><h4 id="Git本地配置"><a href="#Git本地配置" class="headerlink" title="Git本地配置"></a>Git本地配置</h4><p>在本地Git Bash中配置个人名字和邮箱，用来记录提交信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"your_name"</span></div><div class="line">$ git config --global user.email <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure></p><h4 id="SSH-key配置"><a href="#SSH-key配置" class="headerlink" title="SSH key配置"></a>SSH key配置</h4><p>SSH key是用来将本地Git与远程的GitHub关联起来的关键配置。在本地Git bash中执行如下命令：</p><h4 id="1-检查SSH-key的设置"><a href="#1-检查SSH-key的设置" class="headerlink" title="1. 检查SSH key的设置"></a>1. 检查SSH key的设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure><h4 id="2-备份并移除原来的SSH-key"><a href="#2-备份并移除原来的SSH-key" class="headerlink" title="2. 备份并移除原来的SSH key"></a>2. 备份并移除原来的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">$ mkdir key_backup</div><div class="line">$ cp id_rsa* key_backup</div><div class="line">$ rm id_rsa*</div></pre></td></tr></table></figure><h4 id="3-生成新的SSH-key"><a href="#3-生成新的SSH-key" class="headerlink" title="3. 生成新的SSH key"></a>3. 生成新的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure><h4 id="4-添加SSH-key到远程GitHub"><a href="#4-添加SSH-key到远程GitHub" class="headerlink" title="4. 添加SSH key到远程GitHub"></a>4. 添加SSH key到远程GitHub</h4><p>生成的<em>id_rsa</em>是私钥，需要保管好，而公钥<em>id_rsa.pub</em>中的内容需要在个人GitHub主页的Settings里的SSH and GPG keys选项中添加上，title项可根据个人习惯随便写。</p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure><h2 id="Hexo的安装与使用"><a href="#Hexo的安装与使用" class="headerlink" title="Hexo的安装与使用"></a>Hexo的安装与使用</h2><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Hexo是一个快速、简洁且高效的博客框架。在安装完node.js之后，就可以在命令行或git bash中使用npm命令进行安装Hexo了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p><h4 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h4><p>安装完hexo后，在需要的文件夹下（以F:/Hexo为例）右键-&gt;”Git Bash Here”，在git bash中输入如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init <span class="string">"your_blog"</span></div><div class="line">$ hexo g</div><div class="line">$ hexo s</div></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>便能在本地预览博客效果</p><h2 id="发布博客到GitHub-Repo"><a href="#发布博客到GitHub-Repo" class="headerlink" title="发布博客到GitHub Repo"></a>发布博客到GitHub Repo</h2><h4 id="本地仓库跟GitHub建立联系"><a href="#本地仓库跟GitHub建立联系" class="headerlink" title="本地仓库跟GitHub建立联系"></a>本地仓库跟GitHub建立联系</h4><p>在Hexo生成的.deploy_git文件夹下用git将其与远程仓库建立联系（只需要执行一次）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git remote -v</div><div class="line">$ git remote add origin git@github.com:your_name/your_name.github.io.git</div></pre></td></tr></table></figure></p><h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure><p>Hexo还有很多好用的模板可供使用，详细的使用方法此处仅贴几个相关链接，供后续学习使用。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo theme</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo github</a><br><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo 官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了使用hexo在GitHub上搭建博客，特此记录。&lt;/p&gt;
&lt;h2 id=&quot;需要安装的软件&quot;&gt;&lt;a href=&quot;#需要安装的软件&quot; class=&quot;headerlink&quot; title=&quot;需要安装的软件&quot;&gt;&lt;/a&gt;需要安装的软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git&lt;/a&gt;
    
    </summary>
    
      <category term="个人小研究" scheme="http://ssdna.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Hexo" scheme="http://ssdna.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://ssdna.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Apache多站点管理</title>
    <link href="http://ssdna.github.io/2016/07/13/Multisites-Setting-in-Apache/"/>
    <id>http://ssdna.github.io/2016/07/13/Multisites-Setting-in-Apache/</id>
    <published>2016-07-13T11:37:32.000Z</published>
    <updated>2017-10-09T10:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改文件-apache-conftpd-ctf"><a href="#修改文件-apache-conftpd-ctf" class="headerlink" title="修改文件:apache/conftpd.ctf"></a>修改文件:apache/conftpd.ctf</h3><h4 id="找到这两句取消注释"><a href="#找到这两句取消注释" class="headerlink" title="找到这两句取消注释"></a>找到这两句取消注释</h4><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#LoadModule vhost_alias_module modules/mod_vhost_alias.so</span></div><div class="line"><span class="comment">#Include conf/extratpd-vhosts.conf</span></div></pre></td></tr></table></figure><h3 id="在DocumentRoot下添加："><a href="#在DocumentRoot下添加：" class="headerlink" title="在DocumentRoot下添加："></a>在DocumentRoot下添加：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Directory</span> "<span class="attr">F:</span>/<span class="attr">php</span>"&gt;</span></div><div class="line">    Options Indexes FollowSymLinks Includes ExecCGI   </div><div class="line">    AllowOverride All   </div><div class="line">    Require all granted</div><div class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改文件：apache-conf-extratpd-vhosts-conf"><a href="#修改文件：apache-conf-extratpd-vhosts-conf" class="headerlink" title="修改文件：apache/conf/extratpd-vhosts.conf"></a>修改文件：apache/conf/extratpd-vhosts.conf</h3><h4 id="添加以下内容"><a href="#添加以下内容" class="headerlink" title="添加以下内容"></a>添加以下内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></div><div class="line">    DocumentRoot "F:/php"   </div><div class="line">ServerName www.zhangziye.com</div><div class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改C-windows-system32-drivers-detc-hosts"><a href="#修改C-windows-system32-drivers-detc-hosts" class="headerlink" title="修改C:/windows/system32/drivers/detc/hosts"></a>修改C:/windows/system32/drivers/detc/hosts</h3><h4 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h4><blockquote><p>127.0.0.1       www.zhangziye.com##注意前面不要加#号</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改文件-apache-conftpd-ctf&quot;&gt;&lt;a href=&quot;#修改文件-apache-conftpd-ctf&quot; class=&quot;headerlink&quot; title=&quot;修改文件:apache/conftpd.ctf&quot;&gt;&lt;/a&gt;修改文件:apache/conftpd.ctf&lt;/h3&gt;&lt;h4 id=&quot;找到这两句取消注释&quot;&gt;&lt;a href=&quot;#找到这两句取消注释&quot; class=&quot;headerlink&quot; title=&quot;找到这两句取消注释&quot;&gt;&lt;/a&gt;找到这两句取消注释&lt;/h4&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://ssdna.github.io/categories/Apache/"/>
    
    
      <category term="Apache" scheme="http://ssdna.github.io/tags/Apache/"/>
    
  </entry>
  
</feed>
