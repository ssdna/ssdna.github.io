<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DNA&#39; Blog</title>
  
  <subtitle>个人学习记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ssdna.github.io/"/>
  <updated>2017-10-09T10:07:14.000Z</updated>
  <id>http://ssdna.github.io/</id>
  
  <author>
    <name>DNA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RESTful API设计总结</title>
    <link href="http://ssdna.github.io/2017/09/29/A+Note+of+RESTful+API+Design/"/>
    <id>http://ssdna.github.io/2017/09/29/A+Note+of+RESTful+API+Design/</id>
    <published>2017-09-29T02:37:32.000Z</published>
    <updated>2017-10-09T10:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是<code>ThinkPHP5</code>，前端部分用的是<code>vue2+vue-router+vuex</code>的全家桶，用<code>axios</code>进行数据交互。这里总结一下对RESTful API的学习和设计心得。</p><a id="more"></a><h3 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h3><p>RESTful（Representational State Transfer，表现层状态转移）是一种软件架构风格，主要用于客户端（包括浏览器）与服务器端进行数据交互的场景。一个好的RESTful API设计，可以让服务器端只实现一套API接口，就能同时为Web应用、移动端、电脑端同时提供更简洁，更有层次，更易于实现缓存的服务。</p><h3 id="RESTful设计举例"><a href="#RESTful设计举例" class="headerlink" title="RESTful设计举例"></a>RESTful设计举例</h3><p><a href="">知乎</a>上对RESTful API有一条言简意赅的解释：</p><blockquote><p>看<code>url</code>就知道要什么，看<code>http method</code>就知道干什么，看<code>http status code</code>就知道结果如何。</p></blockquote><p>举个例子：如果拿课程(course)作为一个资源，对其进行符合RESTful的API接口设计，其url一般可以设计成如下格式：</p><ul><li>获取课程资源列表<br>[GET] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程资源<br>[GET] <code>http://api.hostname.com/v1/courses/id</code></li><li>新建课程资源<br>[POST] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（全部）<br>[PUT] <code>http://api.hostname.com/v1/courses</code></li><li>更新课程资源（部分）<br>[PATCH] <code>http://api.hostname.com/v1/courses</code></li><li>删除课程资源<br>[DELETE] <code>http://api.hostname.com/v1/courses</code></li><li>获取指定id的课程下的实验资源列表<br>[GET] <code>http://api.hostname.com/v1/courses/id/experiments</code></li><li>获取课程资源列表（分页查询）<br>[GET] <code>http://api.hostname.com/v1/courses?query=&amp;page=2&amp;per_page=100</code></li></ul><p>由上述例子可以看出，RESTful用<code>url</code>来表示一个资源（列表），用<code>HTTP method</code>来表示对资源的增删改查，用<code>http请求参数</code>来对访问的资源作进一步限定。一些实际应用中公认的设计优良的的RESTful API可以参考<a href="">github</a>和<a href="">leancloud</a>。</p><h3 id="RESTful设计准则"><a href="#RESTful设计准则" class="headerlink" title="RESTful设计准则"></a>RESTful设计准则</h3><p>按上述几个方面划分，RESTful设计需要符合如下准则：</p><h4 id="一、url"><a href="#一、url" class="headerlink" title="一、url"></a>一、url</h4><p>RESTful架构中的url代表的是一个资源。url一般需要符合如下要求：</p><ol><li>url中最好加入API的<strong>版本号</strong>信息；</li><li>url中尽量用<strong>名词</strong>表示资源；</li><li>url中尽量用名词的<strong>复数</strong>；</li><li>url中一般会加入可选的<strong>参数</strong>（如<code>id</code>），表示对资源限制条件；</li><li>url中可按需加入过滤信息（如<code>?q=&amp;page=2&amp;per_page=100</code>、<code>?sortby=name&amp;order=asc</code>、<code>?type=1</code>等）；</li></ol><h4 id="二、http-method"><a href="#二、http-method" class="headerlink" title="二、http method"></a>二、http method</h4><p>RESTful中用到的http method如下：</p><ul><li>// 常用</li><li>GET     (SELECT)    ：获出资源（一项或多项）。</li><li>POST    (CREATE)    ：新建一个资源。</li><li>PUT     (UPDATE)    ：更新资源（客户端提供改变后的完整资源）。</li><li>PATCH   (UPDATE)    ：更新资源（客户端只提供待改变部分的属性）。</li><li>DELETE  (DELETE)    ：删除资源。</li><li>// 不常用</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h4 id="三、http-status-code"><a href="#三、http-status-code" class="headerlink" title="三、http status code"></a>三、http status code</h4><p>RESTful API返回的响应结果中，其<strong>http状态码</strong>应该按照http规范对响应结果的状态进行表示。常见的状态码与提示信息如下：</p><ul><li>200 OK                      – [GET] 操作成功</li><li>201 CREATED                 – [POST/PUT/PATCH] 新建/修改数据成功</li><li>204 NO CONTENT              – [DELETE] 删除数据成功</li><li>400 INVALID REQUEST         – [POST/PUT/PATCH] 请求的数据有误</li><li>404 NOT FOUND               – [*] 资源不存在</li><li>500 INTERNAL SERVER ERROR   – [*] 服务器发生错误</li></ul><h4 id="四、other"><a href="#四、other" class="headerlink" title="四、other"></a>四、other</h4><ol><li>对于4xx的错误情况，需要将错误的信息返回，比如<code>{&quot;error&quot;:&quot;没有权限！&quot;}</code>；</li><li>返回的结果尽量使用<strong>json</strong>格式；</li><li>最好添加身份验证，如<code>OAuth 2.0</code>，或<code>api_key</code>;</li><li>最好做到<strong>Hypermedia</strong>，即在返回结果中提供指向该API的说明文档链接或其他相关API的链接。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是&lt;code&gt;ThinkPHP5&lt;/code&gt;，前端部分用的是&lt;code&gt;vue2+vue-router+vuex&lt;/code&gt;的全家桶，用&lt;code&gt;axios&lt;/code&gt;进行数据交互。这里总结一下对RESTful API的学习和设计心得。&lt;/p&gt;
    
    </summary>
    
      <category term="RESTful" scheme="http://ssdna.github.io/categories/RESTful/"/>
    
    
      <category term="RESTful" scheme="http://ssdna.github.io/tags/RESTful/"/>
    
      <category term="API" scheme="http://ssdna.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享技术总结</title>
    <link href="http://ssdna.github.io/2017/09/28/A+Note+of+CORS/"/>
    <id>http://ssdna.github.io/2017/09/28/A+Note+of+CORS/</id>
    <published>2017-09-28T13:25:21.000Z</published>
    <updated>2017-10-09T10:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨域资源共享，即Cross-origin Resource Sharing（下称<code>CORS</code>），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。</p><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><p>浏览器的同源策略</p><h3 id="源的定义"><a href="#源的定义" class="headerlink" title="源的定义"></a>源的定义</h3><p>An origin is defined by the scheme, host, and port of a URL.</p><p>### </p><p>## </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域资源共享，即Cross-origin Resource Sharing（下称&lt;code&gt;CORS&lt;/code&gt;），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的同源策略&quot;&gt;&lt;a href=&quot;#浏览器的同源策略&quot; class=&quot;headerlink&quot; title=&quot;浏览器的同源策略&quot;&gt;&lt;/a&gt;浏览器的同源策略&lt;/h2&gt;&lt;p&gt;浏览器的同源策略&lt;/p&gt;
&lt;h3 id=&quot;源的定义&quot;&gt;&lt;a href=&quot;#源的定义&quot; class=&quot;headerlink&quot; title=&quot;源的定义&quot;&gt;&lt;/a&gt;源的定义&lt;/h3&gt;&lt;p&gt;An origin is defined by the scheme, host, and port of a URL.&lt;/p&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://ssdna.github.io/categories/HTTP/"/>
    
    
      <category term="Browser" scheme="http://ssdna.github.io/tags/Browser/"/>
    
      <category term="HTTP" scheme="http://ssdna.github.io/tags/HTTP/"/>
    
      <category term="ThinkPHP" scheme="http://ssdna.github.io/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>js小技巧之----获取窗口resize完成之后的事件</title>
    <link href="http://ssdna.github.io/2016/07/31/Simulate+%22onresized%22+Event+by+Using+%22settimeout%22/"/>
    <id>http://ssdna.github.io/2016/07/31/Simulate+&quot;onresized&quot;+Event+by+Using+&quot;settimeout&quot;/</id>
    <published>2016-07-30T16:46:31.000Z</published>
    <updated>2017-10-09T10:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>用js可以方便地获取浏览器窗口<code>onResize</code>事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(<code>onResizeCompleted</code>)却比较麻烦。</p><a id="more"></a><h2 id="获取onResize事件"><a href="#获取onResize事件" class="headerlink" title="获取onResize事件"></a>获取<code>onResize</code>事件</h2><h3 id="js原生代码"><a href="#js原生代码" class="headerlink" title="js原生代码"></a>js原生代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth + <span class="string">' '</span> + <span class="built_in">window</span>.innerHeight);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="JQuery代码"><a href="#JQuery代码" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><p>如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log($(<span class="built_in">window</span>).width() + <span class="string">' '</span> + $(<span class="built_in">window</span>).height());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>上面的代码，可以使浏览器在resize的时候在控制台console实时输出当前页面的长、宽像素。这里就不贴图了，可以看到随着鼠标对浏览器窗口的拖动(onResize)时，console里有很多的数据在实时输出。也就是说，上面的函数在resize的时候执行了很多次！</p><p>那么问题来了：如果我想只想监听浏览器窗口resize结束的事件该怎么做呢？也就是说，如果我只想让一个函数在浏览器窗口resize结束之后只执行一次，而不是一直执行，该怎么做呢？</p><h2 id="获取onResizeCompleted事件"><a href="#获取onResizeCompleted事件" class="headerlink" title="获取onResizeCompleted事件"></a>获取<code>onResizeCompleted</code>事件</h2><h3 id="js原生代码-1"><a href="#js原生代码-1" class="headerlink" title="js原生代码"></a>js原生代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">clearTimeout(resizeTimer);</div><div class="line">resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// 此函数会在resize结束的时候执行</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">&#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="JQuery代码-1"><a href="#JQuery代码-1" class="headerlink" title="JQuery代码"></a>JQuery代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resizeTimer;</div><div class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  clearTimeout(resizeTimer);</div><div class="line">  resizeTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 此函数在resize结束的时候执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'onResizeCompleted'</span>);</div><div class="line">  &#125;, <span class="number">250</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里利用setTimeout()函数配合对应的clearTimeout()函数不断被执行，实现了简单的计时器Timer，当resize事件触发后停下来的250ms时间后，执行内部的匿名函数，模拟实现对<code>onResizeCompleted</code>事件的监听。当然，这里的250ms可以根据实际的需求进行自己的设定，不过已经符合大部分的情况了，我在noVNC里也见到过同样的设定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种小技巧，可能会在处理别的类似的事件的时候会有用，有待验证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用js可以方便地获取浏览器窗口&lt;code&gt;onResize&lt;/code&gt;事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(&lt;code&gt;onResizeCompleted&lt;/code&gt;)却比较麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="Event" scheme="http://ssdna.github.io/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>用js弹出浏览器自定义精简窗口</title>
    <link href="http://ssdna.github.io/2016/07/30/Open+and+Control+a+customized+Window+in+Browser/"/>
    <id>http://ssdna.github.io/2016/07/30/Open+and+Control+a+customized+Window+in+Browser/</id>
    <published>2016-07-30T15:28:30.000Z</published>
    <updated>2017-10-09T10:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。<br><a id="more"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以调用如下的函数控制浏览器弹出自定义精简窗口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义新窗口相关的变量</span></div><div class="line"><span class="keyword">var</span> newWindow = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> newWindowName = <span class="string">"new_window"</span>;</div><div class="line"><span class="keyword">var</span> newWindowFeature = <span class="string">"resizable=yes, scrollbars=yes, left=200, top=100, width=600, height=400"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">popUpSimpleWindow</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 判断该窗口是否已经打开</span></div><div class="line"><span class="keyword">if</span>(newWindow == <span class="literal">null</span> || newWindow.closed) &#123;</div><div class="line"><span class="comment">// 打开上述自定义特性的窗口</span></div><div class="line">newWindow = <span class="built_in">window</span>.open(<span class="string">"http://nucNaOH.github.io"</span>, newWindowName, newWindowFeature);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">newWindow.focus();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">popUpSimpleWindow();</div></pre></td></tr></table></figure></p><p>效果如下图：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E7%B2%BE%E7%AE%80%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3.png" alt="精简窗口"></p><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><p>关键的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newWindow = <span class="built_in">window</span>.open(url, newWindowName, newWindowFeature);</div></pre></td></tr></table></figure></p><p>该函数的有三个参数，分别为新窗口的url、新窗口的标识name(String)、新窗口的特性值feature(String，逗号分隔)，还返回该窗口对象的引用nenWindow，我们可以借此加一层判断，实现同时只可以有一个新窗口存在，如最上面的代码。</p><p>其中第三个参数可以自行选择设定。这里先普及一下浏览器页面上各元素的名称：<br><img src="http://oa6lwc3gp.bkt.clouddn.com/image/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E.gif" alt="浏览器介绍"></p><p>参照上面的图，便可通过<code>window.open()</code>函数对新窗口的页面元素进行自定义。比如上面的<code>resizable=yes, scrollbars=yes</code>,还有<code>menubars,titlebars,location</code>等等。</p><p>这里支持4种风格的字符串配置风格：</p><blockquote><ol><li>menubar=yes,toolbar=yes,scrollbars=no</li><li>menubar=on,toolbar=on,scrollbars=off</li><li>menubar=1,toolbar=1,scrollbars=0</li><li>menubar,toolbar,scrollbars(写的有，不写的就没有)</li></ol></blockquote><p>更详细的参数说明请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open" target="_blank" rel="external">JavaScript开发手册</a></p><h3 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h3><ol><li>某些情况下，用户对浏览器的设置可能导致某些特性按用户的设定来，而非js里的设定；</li><li>某些安全软件可能禁止了浏览器弹出新窗口；</li><li>调用window.open()方法以后，远程 URL 不会被立即载入，载入过程是异步的。（实际加载这个URL的时间推迟到当前脚本块执行结束之后。窗口的创建和相关资源的加载异步地进行。）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="http://ssdna.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ajax用JQuery实现的一种个人常用写法</title>
    <link href="http://ssdna.github.io/2016/07/30/Ajax+in+JQuery+and+Primitive+JavaScript/"/>
    <id>http://ssdna.github.io/2016/07/30/Ajax+in+JQuery+and+Primitive+JavaScript/</id>
    <published>2016-07-30T13:23:21.000Z</published>
    <updated>2017-10-09T10:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。</p><a id="more"></a><p> 这种技术在浏览器上应用非常广泛，这里仅记录几种我个人用Ajax时常用的方便调试的写法。</p><h2 id="JQuery写法"><a href="#JQuery写法" class="headerlink" title="JQuery写法"></a>JQuery写法</h2><h3 id="个人自用写法"><a href="#个人自用写法" class="headerlink" title="个人自用写法"></a>个人自用写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    url: <span class="string">"http://nucNaOH.github.io/"</span>,</div><div class="line">    type: <span class="string">"POST"</span>,</div><div class="line">    timeout: <span class="number">5000</span>,</div><div class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,         <span class="comment">// default is true</span></div><div class="line">    data: &#123;</div><div class="line">        text: text</div><div class="line">    &#125;,</div><div class="line">    dataType: <span class="string">"json"</span>,       <span class="comment">// xml,json,jsonp,script,html,text.</span></div><div class="line">    <span class="comment">// 一般从数据库查找出来的结果，返回都是json格式。页面用html</span></div><div class="line">    beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('beforeSend:'+text);</span></div><div class="line">    &#125;,</div><div class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log('success'+data);</span></div><div class="line">    &#125;,</div><div class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// console.log(jqXHR);</span></div><div class="line">        <span class="comment">// 该函数的三个参数：</span></div><div class="line">        <span class="comment">// jqXHR jqXHR, String statusText, String errorThrown</span></div><div class="line">    &#125;,</div><div class="line">    complete : <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, statusText, settings</span>) </span>&#123;</div><div class="line">        <span class="comment">// 无论success、error都会执行，且在success、error之后</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="连贯写法："><a href="#连贯写法：" class="headerlink" title="连贯写法："></a>连贯写法：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</div><div class="line">  .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $( <span class="keyword">this</span> ).addClass( <span class="string">"done"</span> );</div><div class="line">    <span class="comment">// alert( "success" );</span></div><div class="line">  &#125;)</div><div class="line">  .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"error"</span> );</div><div class="line">  &#125;)</div><div class="line">  .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert( <span class="string">"complete"</span> );</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h2 id="原生js写法"><a href="#原生js写法" class="headerlink" title="原生js写法"></a>原生js写法</h2><p>原生的JavaScript实现ajax技术的写法：</p><h3 id="精简版"><a href="#精简版" class="headerlink" title="精简版"></a>精简版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reqListener</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">oReq.onload = reqListener;</div><div class="line">oReq.open(<span class="string">'get'</span>, <span class="string">'some.php'</span>, <span class="literal">true</span>);</div><div class="line">oReq.send();</div></pre></td></tr></table></figure><h3 id="多事件监听版"><a href="#多事件监听版" class="headerlink" title="多事件监听版"></a>多事件监听版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">req.addEventListener(<span class="string">"progress"</span>, updateProgress, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"load"</span>, transferComplete, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"error"</span>, transferFailed, <span class="literal">false</span>);</div><div class="line">req.addEventListener(<span class="string">"abort"</span>, transferCanceled, <span class="literal">false</span>);</div><div class="line"></div><div class="line">req.open();</div><div class="line"></div><div class="line"><span class="comment">// 传输进度监听 (下载)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (evt.lengthComputable) &#123;</div><div class="line">    <span class="keyword">var</span> percentComplete = evt.loaded / evt.total;</div><div class="line"></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 总长度没设置时无法监听进度</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="external">Using XMLHttpRequest</a></li><li><a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">jQuery.ajax()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/categories/JavaScript/"/>
    
    
      <category term="Ajax" scheme="http://ssdna.github.io/tags/Ajax/"/>
    
      <category term="JQuery" scheme="http://ssdna.github.io/tags/JQuery/"/>
    
      <category term="JavaScript" scheme="http://ssdna.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo在GitHub上搭建博客</title>
    <link href="http://ssdna.github.io/2016/07/14/Build+Hexo+Blog+by+Using+GitHub+Pages/"/>
    <id>http://ssdna.github.io/2016/07/14/Build+Hexo+Blog+by+Using+GitHub+Pages/</id>
    <published>2016-07-14T04:08:54.000Z</published>
    <updated>2017-10-09T10:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了使用hexo在GitHub上搭建博客，特此记录。</p><h2 id="需要安装的软件"><a href="#需要安装的软件" class="headerlink" title="需要安装的软件"></a>需要安装的软件</h2><ol><li><a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="external">Git</a><a id="more"></a></li></ol><h2 id="Git与GitHub相关"><a href="#Git与GitHub相关" class="headerlink" title="Git与GitHub相关"></a>Git与GitHub相关</h2><h4 id="注册并创建GitHub仓库"><a href="#注册并创建GitHub仓库" class="headerlink" title="注册并创建GitHub仓库"></a>注册并创建GitHub仓库</h4><p>仓库名字格式应为：<code>githubname.github.io</code>，类型为<code>Public</code>即可。创建成功后会生成该仓库的git地址，格式如下：</p><blockquote><p><a href="https://github.com/your_name/your_name.github.io.git" target="_blank" rel="external">https://github.com/your_name/your_name.github.io.git</a></p></blockquote><h4 id="Git本地配置"><a href="#Git本地配置" class="headerlink" title="Git本地配置"></a>Git本地配置</h4><p>在本地Git Bash中配置个人名字和邮箱，用来记录提交信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"your_name"</span></div><div class="line">$ git config --global user.email <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure></p><h4 id="SSH-key配置"><a href="#SSH-key配置" class="headerlink" title="SSH key配置"></a>SSH key配置</h4><p>SSH key是用来将本地Git与远程的GitHub关联起来的关键配置。在本地Git bash中执行如下命令：</p><h4 id="1-检查SSH-key的设置"><a href="#1-检查SSH-key的设置" class="headerlink" title="1. 检查SSH key的设置"></a>1. 检查SSH key的设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div></pre></td></tr></table></figure><h4 id="2-备份并移除原来的SSH-key"><a href="#2-备份并移除原来的SSH-key" class="headerlink" title="2. 备份并移除原来的SSH key"></a>2. 备份并移除原来的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">$ mkdir key_backup</div><div class="line">$ cp id_rsa* key_backup</div><div class="line">$ rm id_rsa*</div></pre></td></tr></table></figure><h4 id="3-生成新的SSH-key"><a href="#3-生成新的SSH-key" class="headerlink" title="3. 生成新的SSH key"></a>3. 生成新的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@your_email.com"</span></div></pre></td></tr></table></figure><h4 id="4-添加SSH-key到远程GitHub"><a href="#4-添加SSH-key到远程GitHub" class="headerlink" title="4. 添加SSH key到远程GitHub"></a>4. 添加SSH key到远程GitHub</h4><p>生成的<em>id_rsa</em>是私钥，需要保管好，而公钥<em>id_rsa.pub</em>中的内容需要在个人GitHub主页的Settings里的SSH and GPG keys选项中添加上，title项可根据个人习惯随便写。</p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure><h2 id="Hexo的安装与使用"><a href="#Hexo的安装与使用" class="headerlink" title="Hexo的安装与使用"></a>Hexo的安装与使用</h2><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Hexo是一个快速、简洁且高效的博客框架。在安装完node.js之后，就可以在命令行或git bash中使用npm命令进行安装Hexo了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div></pre></td></tr></table></figure></p><h4 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h4><p>安装完hexo后，在需要的文件夹下（以F:/Hexo为例）右键-&gt;”Git Bash Here”，在git bash中输入如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init <span class="string">"your_blog"</span></div><div class="line">$ hexo g</div><div class="line">$ hexo s</div></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>便能在本地预览博客效果</p><h2 id="发布博客到GitHub-Repo"><a href="#发布博客到GitHub-Repo" class="headerlink" title="发布博客到GitHub Repo"></a>发布博客到GitHub Repo</h2><h4 id="本地仓库跟GitHub建立联系"><a href="#本地仓库跟GitHub建立联系" class="headerlink" title="本地仓库跟GitHub建立联系"></a>本地仓库跟GitHub建立联系</h4><p>在Hexo生成的.deploy_git文件夹下用git将其与远程仓库建立联系（只需要执行一次）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git remote -v</div><div class="line">$ git remote add origin git@github.com:your_name/your_name.github.io.git</div></pre></td></tr></table></figure></p><h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure><p>Hexo还有很多好用的模板可供使用，详细的使用方法此处仅贴几个相关链接，供后续学习使用。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo theme</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo github</a><br><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo 官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了使用hexo在GitHub上搭建博客，特此记录。&lt;/p&gt;
&lt;h2 id=&quot;需要安装的软件&quot;&gt;&lt;a href=&quot;#需要安装的软件&quot; class=&quot;headerlink&quot; title=&quot;需要安装的软件&quot;&gt;&lt;/a&gt;需要安装的软件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git&lt;/a&gt;
    
    </summary>
    
      <category term="个人小研究" scheme="http://ssdna.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Hexo" scheme="http://ssdna.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://ssdna.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Apache多站点管理</title>
    <link href="http://ssdna.github.io/2016/07/13/Multisites+Setting+in+Apache/"/>
    <id>http://ssdna.github.io/2016/07/13/Multisites+Setting+in+Apache/</id>
    <published>2016-07-13T11:37:32.000Z</published>
    <updated>2017-10-09T10:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改文件-apache-conftpd-ctf"><a href="#修改文件-apache-conftpd-ctf" class="headerlink" title="修改文件:apache/conftpd.ctf"></a>修改文件:apache/conftpd.ctf</h3><h4 id="找到这两句取消注释"><a href="#找到这两句取消注释" class="headerlink" title="找到这两句取消注释"></a>找到这两句取消注释</h4><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#LoadModule vhost_alias_module modules/mod_vhost_alias.so</span></div><div class="line"><span class="comment">#Include conf/extratpd-vhosts.conf</span></div></pre></td></tr></table></figure><h3 id="在DocumentRoot下添加："><a href="#在DocumentRoot下添加：" class="headerlink" title="在DocumentRoot下添加："></a>在DocumentRoot下添加：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Directory</span> "<span class="attr">F:</span>/<span class="attr">php</span>"&gt;</span></div><div class="line">    Options Indexes FollowSymLinks Includes ExecCGI   </div><div class="line">    AllowOverride All   </div><div class="line">    Require all granted</div><div class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改文件：apache-conf-extratpd-vhosts-conf"><a href="#修改文件：apache-conf-extratpd-vhosts-conf" class="headerlink" title="修改文件：apache/conf/extratpd-vhosts.conf"></a>修改文件：apache/conf/extratpd-vhosts.conf</h3><h4 id="添加以下内容"><a href="#添加以下内容" class="headerlink" title="添加以下内容"></a>添加以下内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></div><div class="line">    DocumentRoot "F:/php"   </div><div class="line">ServerName www.zhangziye.com</div><div class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="修改C-windows-system32-drivers-detc-hosts"><a href="#修改C-windows-system32-drivers-detc-hosts" class="headerlink" title="修改C:/windows/system32/drivers/detc/hosts"></a>修改C:/windows/system32/drivers/detc/hosts</h3><h4 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h4><blockquote><p>127.0.0.1       www.zhangziye.com##注意前面不要加#号</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改文件-apache-conftpd-ctf&quot;&gt;&lt;a href=&quot;#修改文件-apache-conftpd-ctf&quot; class=&quot;headerlink&quot; title=&quot;修改文件:apache/conftpd.ctf&quot;&gt;&lt;/a&gt;修改文件:apache/conftpd.ctf&lt;/h3&gt;&lt;h4 id=&quot;找到这两句取消注释&quot;&gt;&lt;a href=&quot;#找到这两句取消注释&quot; class=&quot;headerlink&quot; title=&quot;找到这两句取消注释&quot;&gt;&lt;/a&gt;找到这两句取消注释&lt;/h4&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://ssdna.github.io/categories/Apache/"/>
    
    
      <category term="Apache" scheme="http://ssdna.github.io/tags/Apache/"/>
    
  </entry>
  
</feed>
