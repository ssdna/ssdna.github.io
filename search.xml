<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web前端涉及到的相关网络协议概述]]></title>
    <url>%2F2018%2F04%2F21%2FFront-End-Related-Network-Protocals-Summary%2F</url>
    <content type="text"><![CDATA[Web前端涉及到的相关网络协议概述HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是建立在TCP协议之上的网络传输协议。 HTTP有如下几个特点： 基于文本的 无状态，有会话的（Cookies） 可扩展的（Header） 可缓存的 HTTP/1.x一个典型的会话过程：在像 HTTP 这样的Client-Server（客户端-服务器）协议中，会话分为三个阶段： 客户端建立一条 TCP 连接（如果传输层不是 TCP，也可以是其他适合的连接）。 客户端发送请求并等待应答。 服务器处理请求并送回应答，回应包括一个状态码和对应的数据。 从 HTTP/1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。 报文 request： 请求由以下元素组成： 一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。 要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。 HTTP协议版本号。 为服务端表达其他信息的可选头部headers。 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与回应报文的body类似。 response： 响应报文包含了下面的元素： HTTP协议版本号。 一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。 HTTP headers，与请求头部类似。 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。 Proxy代理，转发HTTP消息。 作用代理主要有如下几种作用： 缓存（可以是公开的也可以是私有的，像浏览器的缓存） 过滤（像反病毒扫描，家长控制…） 负载均衡（让多个服务器服务不同的请求） 认证（对不同资源进行权限管理） 日志记录（允许存储历史信息） 分类 正向代理 一般由客户端主动设置。客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。 作用： 访问本无法访问的服务器B 加速访问服务器B Cache作用 客户端访问授权 隐藏访问者的行踪 反向代理 客户端不需要进行任何设置，客户端向反向代理发送请求，接着反向代理判断请求走向何处，发送请求，并将返回的响应转交给客户端，客户端并不会感知到反向代理后面的服务，使得这些内容就好似他自己响应的一样。 作用： 保护和隐藏原始资源服务器 加密和SSL加速 负载均衡 缓存静态内容 压缩 减速上传 安全 外网发布 HTTP Method GET 获取被请求 URI（Request-URI）指定的信息。 HEAD 不能在响应里返回消息主体，其响应里的元（头域）信息应该和 GET 请求响应里的元信息一致。 OPTIONS 请求想得到请求/响应链上关于此请求里的 URI（Request-URI）指定资源 的通信选项信息。 POST 用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物。 PUT 请求服务器去把请求里的实体存储在请求 URI（Request-URI）标识下，如果该资源已存在，则更新。 DELETE 请求源服务器删除请求 URI 指定的资源。 TRACE 被用于激发一个远程的、应用层的请求消息回路，不能包含一个实体。 CONNECT 被HTTP1.1 协议规范保留，为了能用于能动态切换到隧道的代理（如：SSL tunneling）。 HTTP CodeHTTP 状态码 1xx 消息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 HTTP CookieCookie 用途: 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Web storage API （ localStorage 和 sessionStorage ）或 IndexedDB 。 创建Cookie: 服务器使用Set-Cookie响应头部向用户代理（User Agent）（一般是浏览器）发送Cookie信息。 1Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt; 之后，用户代理对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送给服务器。 示例： 123456789101112# 响应：设置cookieHTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[页面内容]# 之后的请求：发送cookieGET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry Cookie 类型： 会话期Cookie 会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。 Max-Age: 单位是秒，优先级高于Expires 持久性Cookie 持久性Cookie，和关闭浏览器便失效的会话期Cookie不同，可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。 示例： 12345# 会话期CookieSet-Cookie: id=a3fWa;# 持久性Cookie。Set-Cookie: id=a3fWa; Max-Age=1000;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Cookie 作用域Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。 Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。 例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。 Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。 例如，设置 Path=/docs，则以下地址都会匹配： /docs/docs/Web//docs/Web/HTTP Cookie 安全Document.cookie属性可创建新的Cookie，获取非HttpOnly的Cookie。 会话劫持和XSS 跨站请求伪造（CSRF） HTTP authourizationHTTP CacheCache 目标重用已获取的资源。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存，HEAD请求也可以被缓存，但OPTIONS、POST、PUT、DELETE、TRACE都不可以被缓存，CONNECT方法不具备可缓存cacheable的特性）。 Cache ControlHTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。 Cache-Control的可能取值: private 默认值。表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 public 表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。 no-cache 此方式下，每次有请求发出时，缓存会将此请求发到服务器，服务器端会验证请求中相关验证字段所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本。 no-store 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。 must-revalidate 缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。 Cache 校验 ETag/If-None-Match 强校验器 Last-Modified/If-Modified-Since 弱校验器 Vary 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。 CORSWebSocketHTTP/2与HTTP/1.x主要的区别： 二进制的，而不是文本的；（is binary, instead of textual） 是完全多路复用的，而不是按序和阻塞的；（is fully multiplexed, instead of ordered and blocking） 能用一个（TCP）连接来实现并行（请求）；（can therefore use one connection for parallelism） 压缩头部（header），来减少开销；（uses header compression to reduce overhead） 允许服务器主动地将响应“推”到客户端缓存中。（allows servers to “push” responses proactively into client caches） TCPDNS相关链接 rfc2616 HTTP/1.1 HTTP MDN HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP/2 正向代理与反向代理的区别]]></content>
      <categories>
        <category>Network Protocol</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>Websocket</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承的6种方式]]></title>
    <url>%2F2018%2F04%2F21%2F6-Ways-to-Implement-JS-Inheritance%2F</url>
    <content type="text"><![CDATA[js实现继承的6种方式本文总结自js高程。 原型链 123456789101112131415161718192021// Superfunction SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperProperty = function () &#123; return this.property;&#125;// Subfunction SubType() &#123; this.subProperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubProperty = function () &#123; return this.subProperty;&#125;var instance1 = new SubType();instance1 instanceof SuperType === true; // truevar instance2 = new SubType();instance2.property === instance1.property; // true 缺点： 所有实例共享SuperType原型上的属性，一个被修改，所有的都会被修改； 无法为SuperType的构造函数传递参数； 借用构造函数 123456789101112131415// Superfunction SuperType(name) &#123; this.color = ['red', 'green', 'blue']; this.name = name;&#125;// Subfunction SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;var instance1 = new SubType('wn', 12);var instance2 = new SubType('fyt', 11);instance1.color.push('xxx');console.log(instance1, instance2); 缺点： 无法复用函数 组合继承1234567891011121314151617181920212223242526272829// Superfunction SuperType(name) &#123; this.color = ['red', 'green', 'blue']; this.name = name;&#125;SuperType.prototype.getName = function() &#123; return this.name;&#125;// Subfunction SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.getAge = function () &#123; return this.age;&#125;var instance1 = new SubType('wn', 12);instance1.color.push('xxx');console.log(instance1.getName());console.log(instance1.getAge());var instance2 = new SubType('fyt', 11);console.log(instance2.getName());console.log(instance2.getAge());console.log(instance1, instance2); 缺点： SuperType 需要 new 两次 原型式继承 12345678910111213141516// Object.create() 等价function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"] &#125;;var anotherPerson = object(person); anotherPerson.name = "Greg"; anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person); yetAnotherPerson.name = "Linda"; yetAnotherPerson.friends.push("Barbie");console.log(person.friends);//"Shelby,Court,Van,Rob,Barbie" 缺点： 简单把对象放在新函数的原型上，不涉及到SuperType类及其构造函数初始化。 寄生式继承 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function createAnother(original) &#123; var clone = object(original); // 增强对象 clone.sayHi = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点： 简单把对象放在新函数的原型上，不涉及到SuperType类及其构造函数初始化。 寄生组合式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// inheritPrototypefunction inheritPrototype (subType, superType)&#123; // swallow clone var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;// Superfunction SuperType(name) &#123; this.color = ['red', 'green', 'blue']; this.name = name;&#125;SuperType.prototype.getName = function() &#123; return this.name;&#125;// Subfunction SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);// inheritPrototype函数实现内容，如上：// var prototype = object(SuperType.prototype);// prototype.constructor = SubType;// SubType.prototype = prototype;SubType.prototype.getAge = function () &#123; return this.age;&#125;var instance1 = new SubType('wn', 12);instance1.color.push('xxx');console.log(instance1.getName());console.log(instance1.getAge());var instance2 = new SubType('fyt', 11);console.log(instance2.getName());console.log(instance2.getAge());console.log(instance1, instance2); 缺点： 完美。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识复习之CSS]]></title>
    <url>%2F2017%2F11%2F13%2FReview-of-Front-End-CSS%2F</url>
    <content type="text"><![CDATA[居中问题文本居中1234567/* 文字行 水平居中对齐，如p、h1-h6 */text-align: center;/* 文字块 水平居中对齐 */margin-left: auto;margin-right: auto;/* 文字行和列 垂直居中对齐，需要指定高度，如height、line-height或min-height等 */vertical-align: middle; CSS level 3 居中 水平+垂直居中一体：外层relative，内层absolute+top+transform。 123456789101112div.container &#123; height: 10em; position: relative;&#125;div.container p &#123; margin: 0; position: absolute; top: 50%; left: 50%; margin-right: -50%; /* 注意这里的margin-right! 用来补偿'left:50%'造成的可用元素宽度减少的50%。 详见链接中网页最下方：https://www.w3.org/Style/Examples/007/center.zh_CN.html */ transform: translate(-50%, -50%);&#125; 水平+垂直居中：flex。 1234567891011div.container &#123; height: 10em; display: flex; /* 垂直方向 */ align-items: center; /* 水平方向 */ justify-content: center;&#125;div.container p &#123; margin: 0;&#125; 相关资料： https://www.w3.org/Style/Examples/007/center.zh_CN.html Flexbox布局 Flex Container 1234567display: flex | inline-flex;flex-direction: row | row-reverse | column | column-reverse;flex-wrap: nowrap | wrap | wrap-reverse;flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;;justify-content: flex-start | flex-end | center | space-between | space-around;align-items: flex-start | flex-end | center | baseline | stretch;align-content: flex-start | flex-end | center | space-between | space-around | stretch; Flex Item 123456order: &lt;integer&gt;;flex-grow: &lt;number&gt; (default:0);flex-shrink: &lt;number&gt; (default:1);flex-basis: &lt;length&gt; | auto (default:auto);flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ];align-self: auto | flex-start | flex-end | center | baseline | stretch; 相关资料： http://www.w3cplus.com/css3/a-guide-to-flexbox.html 单位绝对单位 屏幕 单位px，在低分辨率的设备上为1像素，在高分辨率设备上大约为1英尺的1/96。 1in = 96px 打印机 1in = 2.54cm = 25.4mm = 72pt = 6pc 相对单位字体相对单位1234em: 该元素计算后的字体大小rem: 文件的根元素(html)的字体大小ch: 0的字体宽度。ex: 小写字母x的字体高度，1ex约为0.5em 视口百分比长度1234vw: 容器块视口1%的宽度vh: 容器块视口1%的高度vmin: vw和vh中最小的vmax: vw和vh中最大的 相关资料： https://developer.mozilla.org/en-US/docs/Web/CSS/length]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Server-sent Events学习记录]]></title>
    <url>%2F2017%2F10%2F26%2FA-note-of-Server-sent-Events%2F</url>
    <content type="text"><![CDATA[服务器推送事件（Server-sent Events，简称SSE，下同）是HTML5规范中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于WebSocket技术来说，SSE只是单向通信（只能实现服务器向浏览器推送消息，而浏览器不能通过sse向服务器主动发送消息），使用起来也更加简单，对服务器端的改动也比较小，特别适合于诸如监控数据、消息推送等应用场景。 SSE简述Server-sent Events比较简单，主要由两个部分组成： 第一个部分是服务器端与浏览器端之间的通讯协议（基于纯文本）； 第二部分则是在浏览器端可供 JavaScript 使用的 EventSource 对象。 通信协议这里详细介绍SSE的通信协议。 SSE的通讯协议是基于纯文本的简单协议，即服务端和浏览器之间采用纯文本进行通信。 服务器端响应的头部信息（内容类型）Content-Type必须是text/event-stream。 响应文本的内容可以看成是一个事件流（Event stream），由不同的事件所组成。 事件流（Event stream）强制使用UTF8编码，且无法修改编码方式; 每个事件由类型(event)和数据(data)两部分组成，同时每个事件可以有一个可选的标识符(id)。 事件流中每行的结尾可以是CRLF、LF、CR三者中的任意一个。（CRLF是Carriage-Return Line-Feed的缩写，意思是回车换行，就是回车(CR, ASCII 13, \r) 与换行(LF, ASCII 10, \n)） 每个事件的数据可能由多行组成，每个事件之间通过额外的空行（CRLF、LF、CR三者中的任意一个）来分隔。 对于每一行来说，冒号（:）前面表示的是该行的类型，冒号后面则是对应的值（可以为空）。其事件类型如下： 事件类型SSE的事件类型可分为五类。 类型为 空白，表示该行是注释，会在处理时被忽略。举例如下： 空白注释 : 带描述的注释 :this is a commont 类型为 data，表示该行包含的是数据。以data开头的行可以连续出现多次，所有这些行都是该事件的数据。多行data最终的数据每行与每行中间都有一个\n，但最后没有\n。举例如下： 单行data，最终data为：”sse event” data:sse event 多行data，最终data为：”AAAA\nBBBB” data: AAAAdata:BBBB 类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。举例如下： 自定义myevnet，可触发source.addEventListener(&#39;myevent&#39;, (event) =&gt; {console.log(event.data)})。其中，event.data===&#39;my event data\ncontinue&#39; event: myeventdata: my event datadata:continue 类型为 id，表示该行用来声明事件的标识符（整数字符串）。标识符id主要用在尝试重连的请求头Last-Event-ID字段中，给服务器提供信息。举例如下： 指定标识符id，如果此时断开连接，下次重连时的请求头中会自动将’30’放在Last-Event-ID字段中，服务器可以根据这个请求头字段做特定的处理。 id: 30data: dddd 类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间（毫秒数），服务器可以动态调节推送频率。 指定下次重连时间为3000ms，可动态变化 retry: 3000 事件数据服务器端响应内容的示例 12345678910111213data: first eventdata: second eventid: 100event: myeventdata: third eventretry: 3000id: 101: this is a comment，注意最后一行的多余空行data: fourth eventdata: fourth event continue 相关HTTP header12345// 响应头Content-Type:text/event-stream;Cache-Control:no-cache// 请求头（只有在SSE重连时，浏览器端才会找到上一个合法的id，并通过以下请求头字段发送给服务器）Last-Event-ID:2 特别注意 Event stream请求可以通过HTTP状态码301和307进行重定向； 当连接关闭时，浏览器会尝试自动重连，除非收到HTTP状态吗204（No Content）； Event stream中，冒号（:）可以在行首表示改行是注释； Event stream中，非注释行冒号（:）后可以有一个空格，该空格不会计入data buffer中； Event stream中，最后一行如果没有额外的空行，会导致最后一个事件推送不成功； 对于代理服务器，因其在特定情况下会在短暂的延时后断开HTTP连接，设计者可以考虑每隔15s推送一条注释消息； 在SSE重连时，浏览器端会找到上一个合法的id，跳过那些没有设置id的事件，并通过Last-Event-ID请求头字段发送给服务器；如果上一条id为空，则表示清空last event ID string，这种情况下，浏览器重连时并不会发送Last-Event-ID请求头字段。 Event Source对象Event Source对象有4个要点，其中后3个都不暴露在Event Source对象上： url； 请求； 重连事件； last event ID string； Event Source对象有如下API接口： url (read-only); withCredentials (read-only); readyState // CONNECTING (0), OPEN (1), CLOSED (2) EventHandler // onopen, onmessage, onerror close (void) 具体实现方案Browser端目前，除IE外，几乎所有的浏览器都支持sse，即window下有EventSource属性（对象）。对于IE可以使用简易轮询或COMET技术来实现，也可以使用polyfill。 下图是我在Can I use上针对SSE于2017年10月26日的查询结果: 具体实现 1234567891011// constructor. When invoked, must init env &amp; fetch requestvar source = new EventSource('http://localhost/sse.php');// onmessage. Also: 'onopen', 'onerror'source.onmessage = function (event)&#123; console.log(event.data);&#125;;// custom event listener. Also: 'open', 'message', 'error'source.addEventListener('event1', event =&gt; &#123; console.log(event.data);&#125;, false); Server端PHP实现1. 简单版鄙人常用的后台语言是PHP，网上对PHP实现SSE的大部分实现方法如下（来自w3cshool）。 1234567891011121314&lt;?php/** * 简单版 * http://www.w3school.com.cn/html5/html_5_serversentevents.asp */header('Content-Type: text/event-stream');header('Cache-Control: no-cache');date_default_timezone_set('UTC');$time = date('r');echo "event: event1\n";echo "data: The server time is: &#123;$time&#125;\n\n";flush();?&gt; 经测试，上述简单版的PHP代码虽然能实现推送的功能，但这种写法实际上的效果其实跟轮询差不多。之所以这么讲，是因为从chrome开发调试工具的Network里可以看到间歇性的多条类型为eventsource的请求，如下图示。 这是因为浏览器上的EventSource实例默认会自动重连。上述PHP代码实际上只是一个HTTP短连接，只提供一次简短的sse推送。正是由于自动重连的存在，所以每次短暂的sse推送之后，每隔一段时间便会有一次重连再获取一次新的简短的sse推送。 2. while(true)版另一种实现方法是while(true)的写法，虽然又会造成服务器端资源的浪费（例如HTTP长连接等）。 1234567891011121314151617&lt;?php /** * while(true)版 */header('Content-Type: text/event-stream'); header('Cache-Control: no-cache'); date_default_timezone_set('UTC');while (true) &#123; $time = date('r'); echo "data: The server time is: &#123;$time&#125;\n\n"; ob_flush(); flush(); sleep(1);&#125;?&gt; 3. 终极版改进的方法是定时或定次（推送事件的次数）服务器端主动断开HTTP长连接，并根据每次推送事件的id（last-evnet-id）来在再次重连的时候恢复推送记录。 12345678910111213141516171819202122232425262728/** * 改进版，会定时断开长连接，并能根据last event id恢复 * https://github.com/Yaffle/EventSource */&lt;?php header("Content-Type: text/event-stream"); header("Cache-Control: no-store"); header("Access-Control-Allow-Origin: *"); $lastEventId = floatval(isset($_SERVER["HTTP_LAST_EVENT_ID"]) ? $_SERVER["HTTP_LAST_EVENT_ID"] : 0); if ($lastEventId == 0) &#123; $lastEventId = floatval(isset($_GET["lastEventId"]) ? $_GET["lastEventId"] : 0); &#125; echo "retry: 2000\n"; // event-stream $i = $lastEventId; $c = $i + 100; while (++$i &lt; $c) &#123; echo "id: " . $i . "\n"; echo "data: " . $i . ";\n\n"; ob_flush(); flush(); sleep(1); &#125;?&gt; nodejs实现这里使用node自带的http库来实现，简单添加了允许所有域跨域请求的请求头，随机推送一个事件，并且会定次（100次）断开长连接，并能根据last event id恢复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const http = require('http');// optionsconst options = &#123; port: 3003, intervalTime: 3000, interval: null, events: ['connected', 'event1', 'event2', 'event3']&#125;;/** * 会定次断开长连接，并能根据last event id恢复 */const server = http.createServer((request, response) =&gt; &#123; // headers of SSE(Server-sent Events) &amp; CORS(Cross Origin Resources Sharing) response.writeHead(200, &#123; 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Access-Control-Allow-Origin': '*' &#125;); // SSE stream response.write(`retry: $&#123;options.interValTime&#125;\n`); response.write(`event: $&#123;options.events[0]&#125;\n`); response.write(`data: $&#123;new Date().toISOString()&#125;\n\n`); // last event id let lastEventId = 0; if (request.headers["last-event-id"] !== undefined) &#123; lastEventId = Number(request.headers["last-event-id"]); &#125; let i = lastEventId; let c = i + 100; // timeout function const fun = function () &#123; if (++i &lt; c) &#123; // send events randomly const index = Math.floor(Math.random() * 3) + 1; response.write(`id: $&#123;i&#125;\n`); response.write(`event: $&#123;options.events[index]&#125;\n`); response.write(`data: $&#123;new Date().toISOString()&#125;\n\n`); options.interval = setTimeout(fun, options.intervalTime); &#125; else &#123; response.end(); &#125; &#125;; fun(); // close request.connection.addListener('close', function () &#123; console.log('sse server closing...[browser side close]'); clearInterval(options.interval); response.end(); &#125;, false);&#125;)server.listen(options.port); 以上。 参考资料 HTML Specification（强烈建议仔细研读） EventSource polyfill（支持IE的polyfill） HTML5 服务器推送事件（Server-sent Events）实战开发]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>SSE</tag>
        <tag>HTTP</tag>
        <tag>PHP</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API设计总结]]></title>
    <url>%2F2017%2F09%2F29%2FA-Note-of-RESTful-API-Design%2F</url>
    <content type="text"><![CDATA[近期，组内的前后端分离项目中用到了RESTful进行后台API的设计，经过一段时间的学习和实践，我对RESTful API设计有了进一步的认识。该项目中后台部分采用的框架是ThinkPHP5，前端部分用的是vue2+vue-router+vuex的全家桶，用axios进行数据交互。这里总结一下对RESTful API的学习和设计心得。 RESTful简介RESTful（Representational State Transfer，表现层状态转移）是一种软件架构风格，主要用于客户端（包括浏览器）与服务器端进行数据交互的场景。一个好的RESTful API设计，可以让服务器端只实现一套API接口，就能同时为Web应用、移动端、电脑端同时提供更简洁，更有层次，更易于实现缓存的服务。 RESTful设计举例知乎上对RESTful API有一条言简意赅的解释： 看url就知道要什么，看http method就知道干什么，看http status code就知道结果如何。 举个例子：如果拿课程(course)作为一个资源，对其进行符合RESTful的API接口设计，其url一般可以设计成如下格式： 获取课程资源列表[GET] http://api.hostname.com/v1/courses 获取指定id的课程资源[GET] http://api.hostname.com/v1/courses/id 新建课程资源[POST] http://api.hostname.com/v1/courses 更新课程资源（全部）[PUT] http://api.hostname.com/v1/courses 更新课程资源（部分）[PATCH] http://api.hostname.com/v1/courses 删除课程资源[DELETE] http://api.hostname.com/v1/courses 获取指定id的课程下的实验资源列表[GET] http://api.hostname.com/v1/courses/id/experiments 获取课程资源列表（分页查询）[GET] http://api.hostname.com/v1/courses?query=&amp;page=2&amp;per_page=100 由上述例子可以看出，RESTful用url来表示一个资源（列表），用HTTP method来表示对资源的增删改查，用http请求参数来对访问的资源作进一步限定。一些实际应用中公认的设计优良的的RESTful API可以参考github和leancloud。 RESTful设计准则按上述几个方面划分，RESTful设计需要符合如下准则： 一、urlRESTful架构中的url代表的是一个资源。url一般需要符合如下要求： url中最好加入API的版本号信息； url中尽量用名词表示资源； url中尽量用名词的复数； url中一般会加入可选的参数（如id），表示对资源限制条件； url中可按需加入过滤信息（如?q=&amp;page=2&amp;per_page=100、?sortby=name&amp;order=asc、?type=1等）； 二、http methodRESTful中用到的http method如下： // 常用 GET (SELECT) ：获出资源（一项或多项）。 POST (CREATE) ：新建一个资源。 PUT (UPDATE) ：更新资源（客户端提供改变后的完整资源）。 PATCH (UPDATE) ：更新资源（客户端只提供待改变部分的属性）。 DELETE (DELETE) ：删除资源。 // 不常用 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 三、http status codeRESTful API返回的响应结果中，其http状态码应该按照http规范对响应结果的状态进行表示。常见的状态码与提示信息如下： 200 OK – [GET] 操作成功 201 CREATED – [POST/PUT/PATCH] 新建/修改数据成功 204 NO CONTENT – [DELETE] 删除数据成功 400 INVALID REQUEST – [POST/PUT/PATCH] 请求的数据有误 404 NOT FOUND – [*] 资源不存在 500 INTERNAL SERVER ERROR – [*] 服务器发生错误 四、other 对于4xx的错误情况，需要将错误的信息返回，比如{&quot;error&quot;:&quot;没有权限！&quot;}； 返回的结果尽量使用json格式； 最好添加身份验证，如OAuth 2.0，或api_key; 最好做到Hypermedia，即在返回结果中提供指向该API的说明文档链接或其他相关API的链接。]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享技术总结]]></title>
    <url>%2F2017%2F09%2F28%2FA-Note-of-CORS%2F</url>
    <content type="text"><![CDATA[跨域资源共享，即Cross-origin Resource Sharing（下称CORS），又叫跨源资源共享。CORS产生的原因，主要是受浏览器自身的同源策略（Same-origin Policy）限制。 浏览器的同源策略浏览器的同源策略 源的定义An origin is defined by the scheme, host, and port of a URL. ### ##]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Browser</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js小技巧之----获取窗口resize完成之后的事件]]></title>
    <url>%2F2016%2F07%2F31%2FSimulate-onresized-Event-by-Using-settimeout%2F</url>
    <content type="text"><![CDATA[用js可以方便地获取浏览器窗口onResize事件，当窗口在被resize的时候，该事件会不断被触发。然而，想要获取窗口resize完成之后的事件(onResizeCompleted)却比较麻烦。 获取onResize事件js原生代码如下：123window.addEventListener('resize', function() &#123; console.log(window.innerWidth + ' ' + window.innerHeight);&#125;); JQuery代码如下：123$(window).on('resize', function() &#123; console.log($(window).width() + ' ' + $(window).height());&#125;); 上面的代码，可以使浏览器在resize的时候在控制台console实时输出当前页面的长、宽像素。这里就不贴图了，可以看到随着鼠标对浏览器窗口的拖动(onResize)时，console里有很多的数据在实时输出。也就是说，上面的函数在resize的时候执行了很多次！ 那么问题来了：如果我想只想监听浏览器窗口resize结束的事件该怎么做呢？也就是说，如果我只想让一个函数在浏览器窗口resize结束之后只执行一次，而不是一直执行，该怎么做呢？ 获取onResizeCompleted事件js原生代码12345678var resizeTimer;window.addEventListener('resize', function() &#123; clearTimeout(resizeTimer); resizeTimer = setTimeout(function() &#123; // 此函数会在resize结束的时候执行 console.log('onResizeCompleted'); &#125;, 250);&#125;); JQuery代码12345678var resizeTimer;$(window).on('resize', function(e) &#123; clearTimeout(resizeTimer); resizeTimer = setTimeout(function() &#123; // 此函数在resize结束的时候执行 console.log('onResizeCompleted'); &#125;, 250);&#125;); 这里利用setTimeout()函数配合对应的clearTimeout()函数不断被执行，实现了简单的计时器Timer，当resize事件触发后停下来的250ms时间后，执行内部的匿名函数，模拟实现对onResizeCompleted事件的监听。当然，这里的250ms可以根据实际的需求进行自己的设定，不过已经符合大部分的情况了，我在noVNC里也见到过同样的设定。 总结这种小技巧，可能会在处理别的类似的事件的时候会有用，有待验证。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js弹出浏览器自定义精简窗口]]></title>
    <url>%2F2016%2F07%2F30%2FOpen-and-Control-a-customized-Window-in-Browser%2F</url>
    <content type="text"><![CDATA[有时候，由于某些需求，一些网页需要更大块儿的像素区域来展示更多更丰富的信息，这时可通过JavaScript对浏览器边框进行自定义“精简”，来达到这样的目的。 代码实现我们可以调用如下的函数控制浏览器弹出自定义精简窗口。12345678910111213141516// 定义新窗口相关的变量var newWindow = null;var newWindowName = "new_window";var newWindowFeature = "resizable=yes, scrollbars=yes, left=200, top=100, width=600, height=400";function popUpSimpleWindow()&#123; // 判断该窗口是否已经打开 if(newWindow == null || newWindow.closed) &#123; // 打开上述自定义特性的窗口 newWindow = window.open("http://nucNaOH.github.io", newWindowName, newWindowFeature); &#125;else&#123; newWindow.focus(); &#125;&#125;popUpSimpleWindow(); 效果如下图： 原理详解关键的代码如下：1newWindow = window.open(url, newWindowName, newWindowFeature); 该函数的有三个参数，分别为新窗口的url、新窗口的标识name(String)、新窗口的特性值feature(String，逗号分隔)，还返回该窗口对象的引用nenWindow，我们可以借此加一层判断，实现同时只可以有一个新窗口存在，如最上面的代码。 其中第三个参数可以自行选择设定。这里先普及一下浏览器页面上各元素的名称： 参照上面的图，便可通过window.open()函数对新窗口的页面元素进行自定义。比如上面的resizable=yes, scrollbars=yes,还有menubars,titlebars,location等等。 这里支持4种风格的字符串配置风格： menubar=yes,toolbar=yes,scrollbars=no menubar=on,toolbar=on,scrollbars=off menubar=1,toolbar=1,scrollbars=0 menubar,toolbar,scrollbars(写的有，不写的就没有) 更详细的参数说明请参考JavaScript开发手册 额外说明 某些情况下，用户对浏览器的设置可能导致某些特性按用户的设定来，而非js里的设定； 某些安全软件可能禁止了浏览器弹出新窗口； 调用window.open()方法以后，远程 URL 不会被立即载入，载入过程是异步的。（实际加载这个URL的时间推迟到当前脚本块执行结束之后。窗口的创建和相关资源的加载异步地进行。）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax用JQuery实现的一种个人常用写法]]></title>
    <url>%2F2016%2F07%2F30%2FAjax-in-JQuery-and-Primitive-JavaScript%2F</url>
    <content type="text"><![CDATA[Ajax，即Asynchronous JavaScript and XML，翻译过来就是：异步的JavaScript与XML技术。个人的理解是：一种用JS在浏览器上执行的想服务器发送请求以获取相应数据技术，使用它可以很方便地在不更新页面的前提下请求、获取、处理、显示数据。 这种技术在浏览器上应用非常广泛，这里仅记录几种我个人用Ajax时常用的方便调试的写法。 JQuery写法个人自用写法12345678910111213141516171819202122232425$.ajax(&#123; url: "http://nucNaOH.github.io/", type: "POST", timeout: 5000, async: true, // default is true data: &#123; text: text &#125;, dataType: "json", // xml,json,jsonp,script,html,text. // 一般从数据库查找出来的结果，返回都是json格式。页面用html beforeSend: function(jqXHR) &#123; // console.log('beforeSend:'+text); &#125;, success: function(data) &#123; // console.log('success'+data); &#125;, error: function() &#123; // console.log(jqXHR); // 该函数的三个参数： // jqXHR jqXHR, String statusText, String errorThrown &#125;, complete : function(jqXHR, statusText, settings) &#123; // 无论success、error都会执行，且在success、error之后 &#125;&#125;); 连贯写法：1234567891011var jqxhr = $.ajax( "example.php" ) .done(function() &#123; $( this ).addClass( "done" ); // alert( "success" ); &#125;) .fail(function() &#123; alert( "error" ); &#125;) .always(function() &#123; alert( "complete" ); &#125;); 原生js写法原生的JavaScript实现ajax技术的写法： 精简版12345678function reqListener() &#123; console.log(this.responseText);&#125;var oReq = new XMLHttpRequest();oReq.onload = reqListener;oReq.open('get', 'some.php', true);oReq.send(); 多事件监听版123456789101112131415161718var req = new XMLHttpRequest();req.addEventListener("progress", updateProgress, false);req.addEventListener("load", transferComplete, false);req.addEventListener("error", transferFailed, false);req.addEventListener("abort", transferCanceled, false);req.open();// 传输进度监听 (下载)function updateProgress(evt) &#123; if (evt.lengthComputable) &#123; var percentComplete = evt.loaded / evt.total; &#125; else &#123; // 总长度没设置时无法监听进度 &#125;&#125; 相关文章 Using XMLHttpRequest jQuery.ajax() XMLHttpRequest]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Hexo在GitHub上搭建博客]]></title>
    <url>%2F2016%2F07%2F14%2FBuild-Hexo-Blog-by-Using-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[最近学习了使用hexo在GitHub上搭建博客，特此记录。 需要安装的软件 node.js Git Git与GitHub相关注册并创建GitHub仓库仓库名字格式应为：githubname.github.io，类型为Public即可。创建成功后会生成该仓库的git地址，格式如下： https://github.com/your_name/your_name.github.io.git Git本地配置在本地Git Bash中配置个人名字和邮箱，用来记录提交信息。12$ git config --global user.name "your_name"$ git config --global user.email "your_email@your_email.com" SSH key配置SSH key是用来将本地Git与远程的GitHub关联起来的关键配置。在本地Git bash中执行如下命令： 1. 检查SSH key的设置1$ cd ~/.ssh 2. 备份并移除原来的SSH key1234$ ls$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* 3. 生成新的SSH key1$ ssh-keygen -t rsa -C "your_email@your_email.com" 4. 添加SSH key到远程GitHub生成的id_rsa是私钥，需要保管好，而公钥id_rsa.pub中的内容需要在个人GitHub主页的Settings里的SSH and GPG keys选项中添加上，title项可根据个人习惯随便写。 5. 测试1$ ssh -T git@github.com Hexo的安装与使用安装HexoHexo是一个快速、简洁且高效的博客框架。在安装完node.js之后，就可以在命令行或git bash中使用npm命令进行安装Hexo了。1$ npm install hexo-cli -g 使用Hexo安装完hexo后，在需要的文件夹下（以F:/Hexo为例）右键-&gt;”Git Bash Here”，在git bash中输入如下命令123$ hexo init "your_blog"$ hexo g$ hexo s 在浏览器中打开http://localhost:4000便能在本地预览博客效果 发布博客到GitHub Repo本地仓库跟GitHub建立联系在Hexo生成的.deploy_git文件夹下用git将其与远程仓库建立联系（只需要执行一次）123$ git init$ git remote -v$ git remote add origin git@github.com:your_name/your_name.github.io.git 发布博客12$ hexo g$ hexo d Hexo还有很多好用的模板可供使用，详细的使用方法此处仅贴几个相关链接，供后续学习使用。 相关链接Hexo themeHexo githubHexo 官网]]></content>
      <categories>
        <category>个人小研究</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache多站点管理]]></title>
    <url>%2F2016%2F07%2F13%2FMultisites-Setting-in-Apache%2F</url>
    <content type="text"><![CDATA[修改文件:apache/conftpd.ctf找到这两句取消注释 12#LoadModule vhost_alias_module modules/mod_vhost_alias.so#Include conf/extratpd-vhosts.conf 在DocumentRoot下添加：12345&lt;Directory "F:/php"&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Require all granted&lt;/Directory&gt; 修改文件：apache/conf/extratpd-vhosts.conf添加以下内容1234&lt;VirtualHost *:80&gt; DocumentRoot "F:/php" ServerName www.zhangziye.com&lt;/VirtualHost&gt; 修改C:/windows/system32/drivers/detc/hosts添加： 127.0.0.1 www.zhangziye.com##注意前面不要加#号]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
</search>
